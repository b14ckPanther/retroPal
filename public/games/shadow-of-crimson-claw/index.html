<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Shadow of the Crimson Claw - A Nostalgic Adventure</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a12;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            border: 6px solid #8b5a2b;
            box-shadow: 0 0 60px rgba(255, 150, 50, 0.4),
                        0 0 120px rgba(255, 100, 0, 0.2),
                        inset 0 0 100px rgba(0,0,0,0.5);
            border-radius: 10px;
            background: #0a0a12;
        }
        canvas { display: block; image-rendering: pixelated; }

        /* HUD Styles */
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            color: #ffd700;
            text-shadow: 2px 2px 4px #000, 0 0 10px #ff6600;
            font-size: 18px;
            z-index: 100;
            display: none;
            justify-content: space-between;
        }
        #hud-left { display: flex; gap: 20px; }
        #hud-right { display: flex; gap: 20px; }
        #hud-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }
        .hud-item { display: flex; align-items: center; gap: 5px; }

        /* Power-up Timer */
        #powerup-display {
            position: absolute;
            top: 50px;
            left: 10px;
            display: none;
            flex-direction: column;
            gap: 5px;
        }
        .powerup-timer {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        .powerup-bar {
            width: 100px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        .powerup-bar-fill {
            height: 100%;
            transition: width 0.1s linear;
        }

        /* Boss Health Bar */
        #boss-health-container {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            display: none;
            flex-direction: column;
            align-items: center;
        }
        #boss-name {
            color: #ff4444;
            font-size: 20px;
            text-shadow: 2px 2px 4px #000;
            margin-bottom: 5px;
        }
        #boss-health-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border: 2px solid #666;
            border-radius: 10px;
            overflow: hidden;
        }
        #boss-health-fill {
            height: 100%;
            background: linear-gradient(180deg, #ff6666 0%, #cc0000 100%);
            transition: width 0.3s ease;
        }

        /* Menu Styles */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }
        .menu-overlay.active { display: flex; }

        .menu-title {
            font-size: 52px;
            color: #ffd700;
            text-shadow: 3px 3px 6px #000, 0 0 30px #ff4400;
            margin-bottom: 15px;
            letter-spacing: 4px;
            text-align: center;
        }
        .menu-subtitle {
            font-size: 20px;
            color: #ff8800;
            margin-bottom: 40px;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 280px;
        }

        .menu-buttons-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .menu-buttons-primary {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 280px;
        }

        .menu-btn {
            padding: 14px 30px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(180deg, #4a3020 0%, #2a1a10 100%);
            border: 3px solid #8b4513;
            color: #ffd700;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: 2px 2px 2px #000;
            border-radius: 5px;
        }
        .menu-btn:hover {
            background: linear-gradient(180deg, #6a4030 0%, #4a2a20 100%);
            border-color: #ffd700;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        .menu-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .menu-btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }
        .menu-btn.primary {
            padding: 16px 40px;
            font-size: 22px;
            background: linear-gradient(180deg, #5a3828 0%, #3a2018 100%);
            border-color: #cc7722;
        }
        .menu-btn.secondary {
            padding: 12px 25px;
            font-size: 16px;
        }

        /* Level Select Grid */
        .level-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            max-width: 600px;
        }
        .level-card {
            width: 120px;
            height: 100px;
            background: linear-gradient(180deg, #3a2a1a 0%, #1a0a00 100%);
            border: 3px solid #5a3a2a;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .level-card:hover:not(.locked) {
            border-color: #ffd700;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        .level-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .level-card.locked::after {
            content: 'üîí';
            font-size: 30px;
            position: absolute;
        }
        .level-number {
            font-size: 28px;
            color: #ffd700;
        }
        .level-name {
            font-size: 11px;
            color: #aaa;
            text-align: center;
        }
        .level-stars {
            font-size: 14px;
            margin-top: 5px;
        }

        /* Name Entry */
        .name-input {
            padding: 15px 20px;
            font-size: 24px;
            font-family: 'Courier New', monospace;
            background: #1a1a2a;
            border: 3px solid #5a3a2a;
            color: #ffd700;
            text-align: center;
            margin-bottom: 20px;
            width: 300px;
            border-radius: 5px;
        }
        .name-input:focus {
            outline: none;
            border-color: #ffd700;
        }

        /* Settings */
        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 350px;
            margin: 10px 0;
            color: #ffd700;
            font-size: 18px;
        }
        .settings-slider {
            width: 150px;
            height: 10px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 5px;
            outline: none;
        }
        .settings-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #ffd700;
            border-radius: 50%;
            cursor: pointer;
        }
        .settings-toggle {
            width: 50px;
            height: 26px;
            background: #333;
            border-radius: 13px;
            cursor: pointer;
            position: relative;
            transition: background 0.3s;
        }
        .settings-toggle.active { background: #4a4; }
        .settings-toggle::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }
        .settings-toggle.active::after { left: 26px; }

        /* Achievements Grid */
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            max-width: 700px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
        }
        .achievement-card {
            width: 150px;
            padding: 15px;
            background: linear-gradient(180deg, #2a2a3a 0%, #1a1a2a 100%);
            border: 2px solid #444;
            border-radius: 10px;
            text-align: center;
        }
        .achievement-card.unlocked {
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        .achievement-icon { font-size: 30px; }
        .achievement-name {
            font-size: 12px;
            color: #ffd700;
            margin-top: 5px;
        }
        .achievement-desc {
            font-size: 10px;
            color: #888;
            margin-top: 3px;
        }

        /* Leaderboard */
        .leaderboard-table {
            width: 500px;
            border-collapse: collapse;
            color: #ffd700;
        }
        .leaderboard-table th,
        .leaderboard-table td {
            padding: 10px 15px;
            text-align: left;
            border-bottom: 1px solid #333;
        }
        .leaderboard-table th {
            background: #2a1a0a;
            font-size: 14px;
        }
        .leaderboard-table tr:nth-child(even) { background: rgba(255,255,255,0.05); }
        .leaderboard-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .leaderboard-tab {
            padding: 10px 20px;
            background: #2a1a0a;
            border: 2px solid #5a3a2a;
            color: #ffd700;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }
        .leaderboard-tab.active {
            background: #4a3020;
            border-color: #ffd700;
        }

        /* Unlockables */
        .unlockables-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            max-width: 600px;
        }
        .character-card {
            width: 120px;
            height: 150px;
            background: linear-gradient(180deg, #2a2a3a 0%, #1a1a2a 100%);
            border: 3px solid #444;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .character-card:hover { border-color: #888; }
        .character-card.owned { border-color: #4a4; }
        .character-card.selected {
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        .character-card.locked { opacity: 0.7; }
        .character-preview { width: 60px; height: 80px; }
        .character-name {
            font-size: 12px;
            color: #ffd700;
            margin-top: 5px;
        }
        .character-cost {
            font-size: 11px;
            color: #88f;
        }

        /* Toast Notification */
        #toast-container {
            position: absolute;
            top: 80px;
            right: 20px;
            z-index: 500;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .toast {
            padding: 15px 25px;
            background: linear-gradient(180deg, #3a3a1a 0%, #2a2a0a 100%);
            border: 2px solid #ffd700;
            border-radius: 10px;
            color: #ffd700;
            font-size: 16px;
            animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        @keyframes toastIn {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes toastOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100px); opacity: 0; }
        }

        /* Level Complete Screen */
        .level-complete-stats {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 30px 0;
            font-size: 20px;
            color: #ffd700;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            width: 300px;
        }
        .star-rating {
            font-size: 40px;
            margin: 20px 0;
        }

        /* Pause overlay darkens game */
        #pause-overlay {
            background: rgba(0,0,0,0.7);
        }

        /* Game Over */
        .game-over-title {
            font-size: 60px;
            color: #ff4444;
            text-shadow: 3px 3px 6px #000, 0 0 30px #ff0000;
        }

        /* Instructions bar */
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #aaa;
            font-size: 12px;
            text-align: center;
            display: none;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1a1a2a; }
        ::-webkit-scrollbar-thumb { background: #4a3a2a; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6a4a3a; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game"></canvas>

        <!-- HUD (shown during gameplay) -->
        <div id="hud">
            <div id="hud-left">
                <div class="hud-item">‚ù§Ô∏è <span id="health">100</span></div>
                <div class="hud-item">üíé <span id="gems">0</span></div>
                <div class="hud-item">üèÜ <span id="score">0</span></div>
            </div>
            <div id="hud-center">
                <span id="level-name">Level 1: Castle Ruins</span>
            </div>
            <div id="hud-right">
                <div class="hud-item">‚è±Ô∏è <span id="timer">0:00</span></div>
            </div>
        </div>

        <!-- Power-up Display -->
        <div id="powerup-display"></div>

        <!-- Boss Health Bar -->
        <div id="boss-health-container">
            <div id="boss-name">Boss Name</div>
            <div id="boss-health-bar">
                <div id="boss-health-fill" style="width: 100%"></div>
            </div>
        </div>

        <!-- Toast Notifications -->
        <div id="toast-container"></div>

        <!-- Main Menu -->
        <div id="main-menu" class="menu-overlay active">
            <div class="menu-title">SHADOW OF THE CRIMSON CLAW</div>
            <div class="menu-subtitle">A Nostalgic Platforming Adventure</div>
            <div class="menu-buttons-primary">
                <button class="menu-btn primary" onclick="MenuSystem.showNameEntry()">New Game</button>
                <button class="menu-btn primary" id="continue-btn" onclick="MenuSystem.continueGame()" disabled>Continue</button>
                <button class="menu-btn primary" onclick="MenuSystem.showLevelSelect()">Level Select</button>
            </div>
            <div class="menu-buttons-grid">
                <button class="menu-btn secondary" onclick="MenuSystem.showLeaderboard()">Leaderboard</button>
                <button class="menu-btn secondary" onclick="MenuSystem.showAchievements()">Achievements</button>
                <button class="menu-btn secondary" onclick="MenuSystem.showUnlockables()">Unlockables</button>
                <button class="menu-btn secondary" onclick="MenuSystem.showSettings()">Settings</button>
            </div>
            <button class="menu-btn secondary" style="margin-top: 15px;" onclick="MenuSystem.showCredits()">Credits</button>
        </div>

        <!-- Name Entry -->
        <div id="name-entry" class="menu-overlay">
            <div class="menu-title">Enter Your Name</div>
            <input type="text" id="player-name-input" class="name-input" maxlength="12" placeholder="Hero">
            <div class="menu-buttons">
                <button class="menu-btn" onclick="MenuSystem.startNewGame()">Start Adventure</button>
                <button class="menu-btn" onclick="MenuSystem.showMainMenu()">Back</button>
            </div>
        </div>

        <!-- Level Select -->
        <div id="level-select" class="menu-overlay">
            <div class="menu-title">Select Level</div>
            <div class="level-grid" id="level-grid"></div>
            <div class="menu-buttons" style="margin-top: 30px;">
                <button class="menu-btn" onclick="MenuSystem.showMainMenu()">Back</button>
            </div>
        </div>

        <!-- Pause Menu -->
        <div id="pause-overlay" class="menu-overlay">
            <div class="menu-title">Paused</div>
            <div class="menu-buttons">
                <button class="menu-btn" onclick="GameState.resume()">Resume</button>
                <button class="menu-btn" onclick="GameState.restartLevel()">Restart Level</button>
                <button class="menu-btn" onclick="MenuSystem.showSettings()">Settings</button>
                <button class="menu-btn" onclick="GameState.quitToMenu()">Quit to Menu</button>
            </div>
        </div>

        <!-- Game Over -->
        <div id="game-over" class="menu-overlay">
            <div class="game-over-title">GAME OVER</div>
            <div class="level-complete-stats">
                <div class="stat-row"><span>Score:</span><span id="gameover-score">0</span></div>
                <div class="stat-row"><span>Gems:</span><span id="gameover-gems">0</span></div>
            </div>
            <div class="menu-buttons">
                <button class="menu-btn" onclick="GameState.restartLevel()">Try Again</button>
                <button class="menu-btn" onclick="GameState.quitToMenu()">Main Menu</button>
            </div>
        </div>

        <!-- Level Complete -->
        <div id="level-complete" class="menu-overlay">
            <div class="menu-title">Level Complete!</div>
            <div class="star-rating" id="star-rating">‚≠ê‚≠ê‚≠ê</div>
            <div class="level-complete-stats">
                <div class="stat-row"><span>Time:</span><span id="complete-time">0:00</span></div>
                <div class="stat-row"><span>Score:</span><span id="complete-score">0</span></div>
                <div class="stat-row"><span>Gems:</span><span id="complete-gems">0/0</span></div>
                <div class="stat-row"><span>Deaths:</span><span id="complete-deaths">0</span></div>
            </div>
            <div class="menu-buttons">
                <button class="menu-btn" id="next-level-btn" onclick="GameState.nextLevel()">Next Level</button>
                <button class="menu-btn" onclick="GameState.restartLevel()">Replay</button>
                <button class="menu-btn" onclick="GameState.quitToMenu()">Main Menu</button>
            </div>
        </div>

        <!-- Leaderboard -->
        <div id="leaderboard" class="menu-overlay">
            <div class="menu-title">Leaderboard</div>
            <div class="leaderboard-tabs">
                <button class="leaderboard-tab active" onclick="MenuSystem.showLeaderboardTab('overall', event)">Overall</button>
                <button class="leaderboard-tab" onclick="MenuSystem.showLeaderboardTab('level', event)">By Level</button>
            </div>
            <table class="leaderboard-table">
                <thead>
                    <tr><th>#</th><th>Name</th><th>Score</th><th>Gems</th><th>Time</th></tr>
                </thead>
                <tbody id="leaderboard-body"></tbody>
            </table>
            <div class="menu-buttons" style="margin-top: 30px;">
                <button class="menu-btn" onclick="MenuSystem.showMainMenu()">Back</button>
            </div>
        </div>

        <!-- Achievements -->
        <div id="achievements" class="menu-overlay">
            <div class="menu-title">Achievements</div>
            <div class="achievements-grid" id="achievements-grid"></div>
            <div class="menu-buttons" style="margin-top: 30px;">
                <button class="menu-btn" onclick="MenuSystem.showMainMenu()">Back</button>
            </div>
        </div>

        <!-- Unlockables -->
        <div id="unlockables" class="menu-overlay">
            <div class="menu-title">Characters</div>
            <div class="menu-subtitle">üíé <span id="total-gems">0</span> Gems Available</div>
            <div class="unlockables-grid" id="unlockables-grid"></div>
            <div class="menu-buttons" style="margin-top: 30px;">
                <button class="menu-btn" onclick="MenuSystem.showMainMenu()">Back</button>
            </div>
        </div>

        <!-- Settings -->
        <div id="settings" class="menu-overlay">
            <div class="menu-title">Settings</div>
            <div class="settings-row">
                <span>Music Volume</span>
                <input type="range" class="settings-slider" id="music-volume" min="0" max="100" value="50">
            </div>
            <div class="settings-row">
                <span>SFX Volume</span>
                <input type="range" class="settings-slider" id="sfx-volume" min="0" max="100" value="70">
            </div>
            <div class="settings-row">
                <span>Screen Shake</span>
                <div class="settings-toggle active" id="screen-shake-toggle" onclick="MenuSystem.toggleScreenShake()"></div>
            </div>
            <div class="menu-buttons" style="margin-top: 30px;">
                <button class="menu-btn" onclick="MenuSystem.saveSettings(); MenuSystem.goBack()">Save & Back</button>
            </div>
        </div>

        <!-- Credits -->
        <div id="credits" class="menu-overlay">
            <div class="menu-title">Credits</div>
            <div style="color: #ffd700; text-align: center; line-height: 2;">
                <p style="font-size: 20px;">Shadow of the Crimson Claw</p>
                <p style="color: #888;">A Captain Claw-Inspired Adventure</p>
                <br>
                <p>Game Design & Programming</p>
                <p style="color: #888;">nmProfessor</p>
                <br>
                <p>Inspired by</p>
                <p style="color: #888;">Captain Claw (1997)</p>
                <br>
                <p style="font-size: 14px; color: #666;">All art procedurally generated</p>
            </div>
            <div class="menu-buttons" style="margin-top: 30px;">
                <button class="menu-btn" onclick="MenuSystem.showMainMenu()">Back</button>
            </div>
        </div>

        <div id="instructions">
            ARROWS/WASD: Move | SPACE: Jump | X/Click: Attack | C: Dash | ESC: Pause
        </div>
    </div>

<script>
// ============================================
// SHADOW OF THE CRIMSON CLAW
// A Captain Claw-Inspired Nostalgic Platformer
// Full Game with 7 Levels, Bosses, and Progression
// ============================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Game Configuration
const CONFIG = {
    WIDTH: 1280,
    HEIGHT: 720,
    GRAVITY: 0.35,
    FRICTION: 0.88,
    TILE_SIZE: 32,
    POWERUP_DURATION: 600 // 10 seconds at 60fps
};

canvas.width = CONFIG.WIDTH;
canvas.height = CONFIG.HEIGHT;

// ============================================
// SAVE SYSTEM
// ============================================
const SaveManager = {
    SAVE_KEY: 'crimson_claw_save',

    defaultSave: {
        profile: { name: 'Hero', createdAt: null, totalPlayTime: 0 },
        progress: { currentLevel: 1, unlockedLevels: [1], checkpoints: {} },
        stats: { totalScore: 0, totalGems: 0, enemiesDefeated: 0, deathCount: 0 },
        achievements: { unlocked: [], progress: {} },
        unlockables: { characters: ['default'], selectedCharacter: 'default', skins: {} },
        settings: { musicVolume: 50, sfxVolume: 70, screenShake: true },
        levelStats: {},
        leaderboard: []
    },

    data: null,

    init() {
        this.load();
    },

    load() {
        try {
            const saved = localStorage.getItem(this.SAVE_KEY);
            if (saved) {
                this.data = { ...this.defaultSave, ...JSON.parse(saved) };
                // Ensure nested objects are properly merged
                this.data.profile = { ...this.defaultSave.profile, ...this.data.profile };
                this.data.progress = { ...this.defaultSave.progress, ...this.data.progress };
                this.data.stats = { ...this.defaultSave.stats, ...this.data.stats };
                this.data.achievements = { ...this.defaultSave.achievements, ...this.data.achievements };
                this.data.unlockables = { ...this.defaultSave.unlockables, ...this.data.unlockables };
                this.data.settings = { ...this.defaultSave.settings, ...this.data.settings };
            } else {
                this.data = JSON.parse(JSON.stringify(this.defaultSave));
            }
        } catch (e) {
            console.error('Failed to load save:', e);
            this.data = JSON.parse(JSON.stringify(this.defaultSave));
        }
    },

    save() {
        try {
            localStorage.setItem(this.SAVE_KEY, JSON.stringify(this.data));
        } catch (e) {
            console.error('Failed to save:', e);
        }
    },

    hasSaveData() {
        return this.data.profile.createdAt !== null;
    },

    createNewProfile(name) {
        this.data = JSON.parse(JSON.stringify(this.defaultSave));
        this.data.profile.name = name || 'Hero';
        this.data.profile.createdAt = Date.now();
        this.save();
    },

    unlockLevel(level) {
        if (!this.data.progress.unlockedLevels.includes(level)) {
            this.data.progress.unlockedLevels.push(level);
            this.save();
        }
    },

    setCheckpoint(level, checkpoint) {
        this.data.progress.checkpoints[level] = checkpoint;
        this.save();
    },

    getCheckpoint(level) {
        return this.data.progress.checkpoints[level] || null;
    },

    updateLevelStats(level, stats) {
        const existing = this.data.levelStats[level] || { bestTime: Infinity, bestScore: 0, bestGems: 0, stars: 0 };
        this.data.levelStats[level] = {
            bestTime: Math.min(existing.bestTime, stats.time),
            bestScore: Math.max(existing.bestScore, stats.score),
            bestGems: Math.max(existing.bestGems, stats.gems),
            stars: Math.max(existing.stars, stats.stars),
            completed: true
        };
        this.save();
    },

    addToLeaderboard(entry) {
        this.data.leaderboard.push({
            name: this.data.profile.name,
            score: entry.score,
            gems: entry.gems,
            time: entry.time,
            level: entry.level,
            date: Date.now()
        });
        this.data.leaderboard.sort((a, b) => b.score - a.score);
        this.data.leaderboard = this.data.leaderboard.slice(0, 100);
        this.save();
    },

    addGems(amount) {
        this.data.stats.totalGems += amount;
        this.save();
    },

    spendGems(amount) {
        if (this.data.stats.totalGems >= amount) {
            this.data.stats.totalGems -= amount;
            this.save();
            return true;
        }
        return false;
    },

    unlockCharacter(charId) {
        if (!this.data.unlockables.characters.includes(charId)) {
            this.data.unlockables.characters.push(charId);
            this.save();
        }
    },

    selectCharacter(charId) {
        if (this.data.unlockables.characters.includes(charId)) {
            this.data.unlockables.selectedCharacter = charId;
            this.save();
        }
    },

    unlockAchievement(id) {
        if (!this.data.achievements.unlocked.includes(id)) {
            this.data.achievements.unlocked.push(id);
            this.save();
            return true;
        }
        return false;
    },

    updateAchievementProgress(id, value) {
        this.data.achievements.progress[id] = value;
        this.save();
    }
};

// ============================================
// GAME STATE MANAGER
// ============================================
const GameState = {
    current: 'loading',
    previous: null,
    levelStartTime: 0,
    levelDeaths: 0,
    levelGemsCollected: 0,
    levelTotalGems: 0,
    isPaused: false,

    states: ['loading', 'mainMenu', 'nameEntry', 'levelSelect', 'playing', 'paused', 'gameOver', 'levelComplete', 'leaderboard', 'achievements', 'unlockables', 'settings', 'credits'],

    setState(newState) {
        if (!this.states.includes(newState)) {
            console.error('Invalid state:', newState);
            return;
        }
        this.previous = this.current;
        this.current = newState;
        this.onStateChange();
    },

    onStateChange() {
        // Hide all menus
        document.querySelectorAll('.menu-overlay').forEach(el => el.classList.remove('active'));
        document.getElementById('hud').style.display = 'none';
        document.getElementById('instructions').style.display = 'none';
        document.getElementById('boss-health-container').style.display = 'none';
        document.getElementById('powerup-display').style.display = 'none';

        switch (this.current) {
            case 'mainMenu':
                document.getElementById('main-menu').classList.add('active');
                document.getElementById('continue-btn').disabled = !SaveManager.hasSaveData();
                break;
            case 'nameEntry':
                document.getElementById('name-entry').classList.add('active');
                document.getElementById('player-name-input').focus();
                break;
            case 'levelSelect':
                document.getElementById('level-select').classList.add('active');
                MenuSystem.renderLevelGrid();
                break;
            case 'playing':
                document.getElementById('hud').style.display = 'flex';
                document.getElementById('instructions').style.display = 'block';
                document.getElementById('powerup-display').style.display = 'flex';
                this.isPaused = false;
                break;
            case 'paused':
                document.getElementById('pause-overlay').classList.add('active');
                document.getElementById('hud').style.display = 'flex';
                this.isPaused = true;
                break;
            case 'gameOver':
                document.getElementById('game-over').classList.add('active');
                document.getElementById('gameover-score').textContent = game.score;
                document.getElementById('gameover-gems').textContent = game.gems;
                break;
            case 'levelComplete':
                document.getElementById('level-complete').classList.add('active');
                this.showLevelComplete();
                break;
            case 'leaderboard':
                document.getElementById('leaderboard').classList.add('active');
                MenuSystem.renderLeaderboard();
                break;
            case 'achievements':
                document.getElementById('achievements').classList.add('active');
                MenuSystem.renderAchievements();
                break;
            case 'unlockables':
                document.getElementById('unlockables').classList.add('active');
                MenuSystem.renderUnlockables();
                break;
            case 'settings':
                document.getElementById('settings').classList.add('active');
                MenuSystem.loadSettings();
                break;
            case 'credits':
                document.getElementById('credits').classList.add('active');
                break;
        }
    },

    showLevelComplete() {
        const elapsed = Math.floor((Date.now() - this.levelStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;

        document.getElementById('complete-time').textContent = timeStr;
        document.getElementById('complete-score').textContent = game.score;
        document.getElementById('complete-gems').textContent = `${this.levelGemsCollected}/${this.levelTotalGems}`;
        document.getElementById('complete-deaths').textContent = this.levelDeaths;

        // Calculate stars
        const level = LevelManager.currentLevelData;
        let stars = 1; // Completed = 1 star
        if (this.levelGemsCollected >= this.levelTotalGems * 0.8) stars = 2;
        if (this.levelDeaths === 0 && elapsed <= (level.parTime || 180)) stars = 3;

        document.getElementById('star-rating').textContent = '‚≠ê'.repeat(stars) + '‚òÜ'.repeat(3 - stars);

        // Save stats
        SaveManager.updateLevelStats(LevelManager.currentLevel, {
            time: elapsed,
            score: game.score,
            gems: this.levelGemsCollected,
            stars: stars
        });

        // Unlock next level
        if (LevelManager.currentLevel < 7) {
            SaveManager.unlockLevel(LevelManager.currentLevel + 1);
            document.getElementById('next-level-btn').style.display = 'block';
        } else {
            document.getElementById('next-level-btn').style.display = 'none';
        }

        // Add to leaderboard
        SaveManager.addToLeaderboard({
            score: game.score,
            gems: this.levelGemsCollected,
            time: elapsed,
            level: LevelManager.currentLevel
        });

        // Check achievements
        AchievementSystem.checkLevelComplete(stars, elapsed, this.levelDeaths);
    },

    startLevel(levelNum) {
        LevelManager.loadLevel(levelNum);
        this.levelStartTime = Date.now();
        this.levelDeaths = 0;
        this.levelGemsCollected = 0;
        this.levelTotalGems = game.treasures.filter(t => t.type === 'gem' || t.type === 'coin' || t.type === 'chest').length;
        this.setState('playing');
        if (!game.audioInitialized) {
            game.audio = new AudioSystem();
            game.audioInitialized = true;
        }
        game.audio.playLevelMusic(levelNum);
    },

    pause() {
        if (this.current === 'playing') {
            this.setState('paused');
        }
    },

    resume() {
        if (this.current === 'paused') {
            this.setState('playing');
        }
    },

    restartLevel() {
        this.levelDeaths = 0;
        this.levelGemsCollected = 0;
        LevelManager.loadLevel(LevelManager.currentLevel);
        this.levelStartTime = Date.now();
        this.setState('playing');
    },

    nextLevel() {
        if (LevelManager.currentLevel < 7) {
            this.startLevel(LevelManager.currentLevel + 1);
        } else {
            this.quitToMenu();
        }
    },

    quitToMenu() {
        this.setState('mainMenu');
        game.audio?.stopMusic();
    },

    playerDied() {
        this.levelDeaths++;
        SaveManager.data.stats.deathCount++;
        SaveManager.save();
    },

    gameOver() {
        this.setState('gameOver');
        game.audio?.playSound('gameOver');
    },

    levelComplete() {
        this.setState('levelComplete');
        game.audio?.playSound('victory');
    }
};

// ============================================
// MENU SYSTEM
// ============================================
const MenuSystem = {
    previousScreen: 'mainMenu',

    showMainMenu() {
        GameState.setState('mainMenu');
    },

    showNameEntry() {
        this.previousScreen = 'mainMenu';
        GameState.setState('nameEntry');
    },

    startNewGame() {
        const name = document.getElementById('player-name-input').value.trim() || 'Hero';
        SaveManager.createNewProfile(name);
        GameState.startLevel(1);
    },

    continueGame() {
        const lastLevel = SaveManager.data.progress.currentLevel || 1;
        GameState.startLevel(lastLevel);
    },

    showLevelSelect() {
        this.previousScreen = 'mainMenu';
        GameState.setState('levelSelect');
    },

    renderLevelGrid() {
        const grid = document.getElementById('level-grid');
        grid.innerHTML = '';

        const levelNames = [
            'Castle Ruins', 'Haunted Forest', 'Crystal Caves', 'Sunken Temple',
            'Volcanic Depths', 'Ancient Ruins', 'Sky Temple'
        ];

        for (let i = 1; i <= 7; i++) {
            const isUnlocked = SaveManager.data.progress.unlockedLevels.includes(i);
            const stats = SaveManager.data.levelStats[i];
            const stars = stats?.stars || 0;

            const card = document.createElement('div');
            card.className = `level-card ${isUnlocked ? '' : 'locked'}`;
            card.innerHTML = `
                <div class="level-number" style="display: ${isUnlocked ? 'block' : 'none'}">${i}</div>
                <div class="level-name">${levelNames[i - 1]}</div>
                <div class="level-stars">${'‚≠ê'.repeat(stars)}${'‚òÜ'.repeat(3 - stars)}</div>
            `;
            if (isUnlocked) {
                card.onclick = () => GameState.startLevel(i);
            }
            grid.appendChild(card);
        }
    },

    showLeaderboard() {
        this.previousScreen = 'mainMenu';
        GameState.setState('leaderboard');
    },

    showLeaderboardTab(tab, e) {
        document.querySelectorAll('.leaderboard-tab').forEach(t => t.classList.remove('active'));
        if (e && e.target) e.target.classList.add('active');
        this.renderLeaderboard(tab);
    },

    renderLeaderboard(tab = 'overall') {
        const tbody = document.getElementById('leaderboard-body');
        let entries = [...SaveManager.data.leaderboard];

        if (tab === 'level') {
            // Group by level, show best per level
            const byLevel = {};
            entries.forEach(e => {
                if (!byLevel[e.level] || e.score > byLevel[e.level].score) {
                    byLevel[e.level] = e;
                }
            });
            entries = Object.values(byLevel).sort((a, b) => a.level - b.level);
        } else {
            entries = entries.slice(0, 10);
        }

        tbody.innerHTML = entries.map((e, i) => {
            const time = typeof e.time === 'number' ?
                `${Math.floor(e.time / 60)}:${(e.time % 60).toString().padStart(2, '0')}` : e.time;
            return `<tr>
                <td>${i + 1}</td>
                <td>${e.name}</td>
                <td>${e.score}</td>
                <td>${e.gems}</td>
                <td>${time}</td>
            </tr>`;
        }).join('');

        if (entries.length === 0) {
            tbody.innerHTML = '<tr><td colspan="5" style="text-align:center;color:#888;">No scores yet!</td></tr>';
        }
    },

    showAchievements() {
        this.previousScreen = 'mainMenu';
        GameState.setState('achievements');
    },

    renderAchievements() {
        const grid = document.getElementById('achievements-grid');
        grid.innerHTML = '';

        AchievementSystem.achievements.forEach(ach => {
            const isUnlocked = SaveManager.data.achievements.unlocked.includes(ach.id);
            const progress = SaveManager.data.achievements.progress[ach.id] || 0;

            const card = document.createElement('div');
            card.className = `achievement-card ${isUnlocked ? 'unlocked' : ''}`;
            card.innerHTML = `
                <div class="achievement-icon">${isUnlocked ? ach.icon : 'üîí'}</div>
                <div class="achievement-name">${ach.name}</div>
                <div class="achievement-desc">${ach.description}</div>
                ${ach.target && !isUnlocked ? `<div style="color:#666;font-size:10px;">${progress}/${ach.target}</div>` : ''}
            `;
            grid.appendChild(card);
        });
    },

    showUnlockables() {
        this.previousScreen = 'mainMenu';
        GameState.setState('unlockables');
    },

    renderUnlockables() {
        const grid = document.getElementById('unlockables-grid');
        grid.innerHTML = '';
        document.getElementById('total-gems').textContent = SaveManager.data.stats.totalGems;

        Characters.list.forEach(char => {
            const isOwned = SaveManager.data.unlockables.characters.includes(char.id);
            const isSelected = SaveManager.data.unlockables.selectedCharacter === char.id;

            const card = document.createElement('div');
            card.className = `character-card ${isOwned ? 'owned' : 'locked'} ${isSelected ? 'selected' : ''}`;

            // Create mini canvas for character preview
            const previewCanvas = document.createElement('canvas');
            previewCanvas.width = 60;
            previewCanvas.height = 80;
            previewCanvas.className = 'character-preview';
            const previewCtx = previewCanvas.getContext('2d');
            Sprites.drawPixelCharacter(previewCtx, 30, 65, 0, true, 'idle', false, char.colors);

            card.appendChild(previewCanvas);
            card.innerHTML += `
                <div class="character-name">${char.name}</div>
                <div class="character-cost">${isOwned ? (isSelected ? '‚úì Selected' : 'Owned') : `üíé ${char.cost}`}</div>
            `;

            card.onclick = () => {
                if (isOwned) {
                    SaveManager.selectCharacter(char.id);
                    this.renderUnlockables();
                } else if (SaveManager.spendGems(char.cost)) {
                    SaveManager.unlockCharacter(char.id);
                    SaveManager.selectCharacter(char.id);
                    this.renderUnlockables();
                    ToastSystem.show(`Unlocked ${char.name}!`);
                } else {
                    ToastSystem.show('Not enough gems!');
                }
            };

            grid.appendChild(card);
        });
    },

    showSettings() {
        this.previousScreen = GameState.current === 'paused' ? 'paused' : 'mainMenu';
        GameState.setState('settings');
    },

    loadSettings() {
        document.getElementById('music-volume').value = SaveManager.data.settings.musicVolume;
        document.getElementById('sfx-volume').value = SaveManager.data.settings.sfxVolume;
        const shakeToggle = document.getElementById('screen-shake-toggle');
        shakeToggle.classList.toggle('active', SaveManager.data.settings.screenShake);
    },

    saveSettings() {
        SaveManager.data.settings.musicVolume = parseInt(document.getElementById('music-volume').value);
        SaveManager.data.settings.sfxVolume = parseInt(document.getElementById('sfx-volume').value);
        SaveManager.save();
        if (game.audio) {
            game.audio.setMusicVolume(SaveManager.data.settings.musicVolume / 100);
            game.audio.setSfxVolume(SaveManager.data.settings.sfxVolume / 100);
        }
    },

    toggleScreenShake() {
        SaveManager.data.settings.screenShake = !SaveManager.data.settings.screenShake;
        document.getElementById('screen-shake-toggle').classList.toggle('active', SaveManager.data.settings.screenShake);
    },

    showCredits() {
        this.previousScreen = 'mainMenu';
        GameState.setState('credits');
    },

    goBack() {
        if (this.previousScreen === 'paused') {
            GameState.setState('paused');
        } else {
            GameState.setState('mainMenu');
        }
    }
};

// ============================================
// TOAST NOTIFICATION SYSTEM
// ============================================
const ToastSystem = {
    show(message, duration = 3000) {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.textContent = message;
        container.appendChild(toast);
        setTimeout(() => toast.remove(), duration);
    }
};

// ============================================
// ACHIEVEMENT SYSTEM
// ============================================
const AchievementSystem = {
    achievements: [
        // Combat
        { id: 'first_blood', name: 'First Blood', description: 'Defeat your first enemy', icon: '‚öîÔ∏è' },
        { id: 'skeleton_slayer', name: 'Skeleton Slayer', description: 'Defeat 50 skeletons', icon: 'üíÄ', target: 50 },
        { id: 'ghost_buster', name: 'Ghost Buster', description: 'Defeat 25 ghosts', icon: 'üëª', target: 25 },
        { id: 'boss_hunter', name: 'Boss Hunter', description: 'Defeat all bosses', icon: 'üèÜ', target: 6 },

        // Collection
        { id: 'treasure_hunter', name: 'Treasure Hunter', description: 'Collect 100 gems', icon: 'üíé', target: 100 },
        { id: 'completionist', name: 'Completionist', description: '100% a level', icon: '‚ú®' },
        { id: 'wealthy', name: 'Wealthy', description: 'Collect 1000 total gems', icon: 'üëë', target: 1000 },

        // Skill
        { id: 'speedrunner', name: 'Speedrunner', description: 'Complete a level under 2 min', icon: '‚ö°' },
        { id: 'untouchable', name: 'Untouchable', description: 'Complete a level without damage', icon: 'üõ°Ô∏è' },
        { id: 'perfectionist', name: 'Perfectionist', description: '3-star a level', icon: 'üåü' },

        // Exploration
        { id: 'secret_finder', name: 'Secret Finder', description: 'Find a secret area', icon: 'üîç' },
        { id: 'explorer', name: 'Explorer', description: 'Find all secret areas', icon: 'üó∫Ô∏è', target: 7 },

        // Milestones
        { id: 'rising_hero', name: 'Rising Hero', description: 'Complete Level 1', icon: 'üåÖ' },
        { id: 'halfway', name: 'Halfway There', description: 'Complete Level 4', icon: 'üèîÔ∏è' },
        { id: 'champion', name: 'Champion', description: 'Complete all 7 levels', icon: 'üéñÔ∏è' },

        // Misc
        { id: 'persistent', name: 'Persistent', description: 'Die 50 times total', icon: 'üí™', target: 50 },
        { id: 'power_collector', name: 'Power Collector', description: 'Use all power-up types', icon: 'üîÆ', target: 5 },
        { id: 'dash_master', name: 'Dash Master', description: 'Dash 100 times', icon: 'üí®', target: 100 },
        { id: 'no_sword', name: 'Pacifist', description: 'Complete a level without attacking', icon: '‚òÆÔ∏è' },
        { id: 'all_chars', name: 'Collector', description: 'Unlock all characters', icon: 'üë•', target: 4 }
    ],

    check(id, value = 1) {
        const ach = this.achievements.find(a => a.id === id);
        if (!ach) return;

        if (ach.target) {
            const current = (SaveManager.data.achievements.progress[id] || 0) + value;
            SaveManager.updateAchievementProgress(id, current);
            if (current >= ach.target) {
                this.unlock(id);
            }
        } else {
            this.unlock(id);
        }
    },

    unlock(id) {
        if (SaveManager.unlockAchievement(id)) {
            const ach = this.achievements.find(a => a.id === id);
            ToastSystem.show(`üèÜ Achievement: ${ach.name}!`);
            game.audio?.playSound('achievement');
        }
    },

    checkLevelComplete(stars, time, deaths) {
        const level = LevelManager.currentLevel;

        if (level === 1) this.check('rising_hero');
        if (level === 4) this.check('halfway');
        if (level === 7) this.check('champion');

        if (stars === 3) this.check('perfectionist');
        if (time <= 120) this.check('speedrunner');
        if (deaths === 0 && game.player.damageTaken === 0) this.check('untouchable');
    },

    checkEnemyKill(type) {
        this.check('first_blood');
        if (type === 'skeleton') this.check('skeleton_slayer');
        if (type === 'ghost') this.check('ghost_buster');
        if (type.includes('boss')) this.check('boss_hunter');
    }
};

// ============================================
// CHARACTER DEFINITIONS
// ============================================
const Characters = {
    list: [
        {
            id: 'default',
            name: 'Crimson Hero',
            cost: 0,
            stats: { speed: 1, health: 100, damage: 1, jumpHeight: 1 },
            colors: { skin: '#e8b89d', hair: '#2a1a0a', shirt: '#8b0000', pants: '#1a1a3a', boots: '#3a2a1a', cape: '#cc0000' }
        },
        {
            id: 'ninja',
            name: 'Shadow Ninja',
            cost: 500,
            stats: { speed: 1.3, health: 75, damage: 1, jumpHeight: 1.15 },
            colors: { skin: '#e8b89d', hair: '#111', shirt: '#222', pants: '#111', boots: '#222', cape: '#333' }
        },
        {
            id: 'knight',
            name: 'Iron Knight',
            cost: 750,
            stats: { speed: 0.8, health: 150, damage: 1.25, jumpHeight: 0.9 },
            colors: { skin: '#e8b89d', hair: '#4a4a4a', shirt: '#6a6a7a', pants: '#5a5a6a', boots: '#4a4a5a', cape: '#3a3a4a' }
        },
        {
            id: 'pirate',
            name: 'Pirate Captain',
            cost: 1000,
            stats: { speed: 1, health: 100, damage: 1.1, jumpHeight: 1, attackRange: 1.2 },
            colors: { skin: '#d4a574', hair: '#1a0a00', shirt: '#4a2a1a', pants: '#2a2a4a', boots: '#2a1a0a', cape: '#8b0000' }
        }
    ],

    getCurrent() {
        const id = SaveManager.data.unlockables.selectedCharacter;
        return this.list.find(c => c.id === id) || this.list[0];
    }
};

// ============================================
// LEVEL MANAGER
// ============================================
const LevelManager = {
    currentLevel: 1,
    currentLevelData: null,
    transitioning: false,
    transitionAlpha: 0,

    loadLevel(levelNum) {
        this.currentLevel = levelNum;
        this.currentLevelData = LEVELS[levelNum];
        SaveManager.data.progress.currentLevel = levelNum;
        SaveManager.save();

        // Update HUD
        document.getElementById('level-name').textContent = `Level ${levelNum}: ${this.currentLevelData.name}`;

        // Reset game state
        game.frame = 0;
        game.cameraX = 0;
        game.screenShake = 0;
        game.gems = 0;
        game.score = 0;
        game.health = Characters.getCurrent().stats.health;

        // Initialize level
        const lvl = this.currentLevelData;
        game.player = new Player(lvl.playerStart.x, lvl.playerStart.y);
        game.enemies = lvl.enemies.map(e => e.type.includes('boss') ? new Boss(e) : new Enemy(e));
        game.treasures = lvl.treasures.map(t => new Treasure(t));
        game.checkpoints = lvl.checkpoints.map(c => new Checkpoint(c));
        game.powerups = (lvl.powerups || []).map(p => new PowerUp(p));
        game.hazards = lvl.hazards || [];
        game.platforms = lvl.platforms;
        game.decorations = lvl.decorations || [];
        game.levelWidth = lvl.width;
        game.levelHeight = lvl.height;
        game.background = new Background(lvl.theme);

        // Update UI
        document.getElementById('health').textContent = game.health;
        document.getElementById('gems').textContent = game.gems;
        document.getElementById('score').textContent = game.score;

        // Check for checkpoint
        const checkpoint = SaveManager.getCheckpoint(levelNum);
        if (checkpoint) {
            game.player.x = checkpoint.x;
            game.player.y = checkpoint.y;
            game.gems = checkpoint.gems || 0;
            game.score = checkpoint.score || 0;
        }
    },

    update() {
        if (this.transitioning) {
            // Handle fade transition
        }
    }
};

// ============================================
// LEVEL DATA - 7 LEVELS
// ============================================
const LEVELS = {
    // LEVEL 1: Castle Ruins (Tutorial)
    1: {
        name: 'Castle Ruins',
        theme: 'castle',
        width: 3200,
        height: 640,
        parTime: 180,
        playerStart: { x: 100, y: 400 },

        platforms: [
            // Ground sections
            { x: 0, y: 560, w: 400, h: 80, type: 'ground' },
            { x: 450, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 700, y: 560, w: 300, h: 80, type: 'ground' },
            { x: 1050, y: 560, w: 150, h: 80, type: 'ground' },
            { x: 1250, y: 560, w: 500, h: 80, type: 'ground' },
            { x: 1800, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 2050, y: 560, w: 300, h: 80, type: 'ground' },
            { x: 2400, y: 560, w: 400, h: 80, type: 'ground' },
            { x: 2850, y: 560, w: 350, h: 80, type: 'ground' },

            // Floating platforms
            { x: 150, y: 450, w: 120, h: 25, type: 'stone' },
            { x: 350, y: 380, w: 100, h: 25, type: 'stone' },
            { x: 550, y: 450, w: 100, h: 25, type: 'wood' },
            { x: 720, y: 350, w: 150, h: 25, type: 'stone' },
            { x: 950, y: 420, w: 80, h: 25, type: 'wood' },
            { x: 1100, y: 350, w: 100, h: 25, type: 'stone' },
            { x: 1300, y: 450, w: 120, h: 25, type: 'wood' },
            { x: 1450, y: 380, w: 100, h: 25, type: 'stone' },
            { x: 1600, y: 300, w: 150, h: 25, type: 'stone' },
            { x: 1850, y: 400, w: 100, h: 25, type: 'wood' },
            { x: 2000, y: 320, w: 120, h: 25, type: 'stone' },
            { x: 2200, y: 400, w: 100, h: 25, type: 'wood' },
            { x: 2400, y: 350, w: 150, h: 25, type: 'stone' },
            { x: 2650, y: 420, w: 100, h: 25, type: 'wood' },
            { x: 2850, y: 350, w: 120, h: 25, type: 'stone' },
            { x: 3000, y: 280, w: 150, h: 25, type: 'stone' },

            // High platforms with secrets
            { x: 200, y: 280, w: 80, h: 20, type: 'wood' },
            { x: 800, y: 220, w: 100, h: 20, type: 'stone' },
            { x: 1700, y: 200, w: 120, h: 20, type: 'stone' },
        ],

        checkpoints: [
            { x: 100, y: 520, id: 0 },
            { x: 1400, y: 520, id: 1 },
            { x: 2600, y: 520, id: 2 }
        ],

        treasures: [
            { x: 180, y: 420, type: 'coin' }, { x: 220, y: 420, type: 'coin' },
            { x: 380, y: 350, type: 'coin' }, { x: 580, y: 420, type: 'coin' },
            { x: 750, y: 320, type: 'gem' }, { x: 980, y: 390, type: 'coin' },
            { x: 1130, y: 320, type: 'coin' }, { x: 1330, y: 420, type: 'coin' },
            { x: 1480, y: 350, type: 'gem' }, { x: 1650, y: 270, type: 'coin' },
            { x: 1880, y: 370, type: 'coin' }, { x: 2030, y: 290, type: 'gem' },
            { x: 2230, y: 370, type: 'coin' }, { x: 2450, y: 320, type: 'coin' },
            { x: 2680, y: 390, type: 'coin' }, { x: 2900, y: 320, type: 'gem' },
            { x: 3050, y: 250, type: 'chest' },
            // Health pickups
            { x: 600, y: 530, type: 'health' },
            { x: 1400, y: 530, type: 'health' },
            { x: 2300, y: 530, type: 'health' },
            // Secret gems
            { x: 230, y: 250, type: 'gem' },
            { x: 830, y: 190, type: 'gem' },
            { x: 1730, y: 170, type: 'gem' },
        ],

        enemies: [
            { x: 500, y: 510, type: 'skeleton', patrolStart: 450, patrolEnd: 650 },
            { x: 900, y: 510, type: 'skeleton', patrolStart: 850, patrolEnd: 1000 },
            { x: 1350, y: 510, type: 'skeleton', patrolStart: 1280, patrolEnd: 1500 },
            { x: 1950, y: 510, type: 'skeleton', patrolStart: 1850, patrolEnd: 2050 },
            { x: 2550, y: 510, type: 'skeleton', patrolStart: 2450, patrolEnd: 2700 },
            { x: 780, y: 300, type: 'ghost', patrolStart: 720, patrolEnd: 870 },
            { x: 1650, y: 250, type: 'ghost', patrolStart: 1600, patrolEnd: 1750 },
        ],

        powerups: [
            { x: 1200, y: 320, type: 'doubleJump' },
        ],

        hazards: [],

        decorations: []
    },

    // LEVEL 2: Haunted Forest
    2: {
        name: 'Haunted Forest',
        theme: 'forest',
        width: 3600,
        height: 640,
        parTime: 200,
        playerStart: { x: 100, y: 400 },

        platforms: [
            // Ground with gaps
            { x: 0, y: 560, w: 300, h: 80, type: 'ground' },
            { x: 380, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 650, y: 560, w: 250, h: 80, type: 'ground' },
            { x: 980, y: 560, w: 180, h: 80, type: 'ground' },
            { x: 1240, y: 560, w: 300, h: 80, type: 'ground' },
            { x: 1620, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 1900, y: 560, w: 250, h: 80, type: 'ground' },
            { x: 2230, y: 560, w: 300, h: 80, type: 'ground' },
            { x: 2600, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 2880, y: 560, w: 350, h: 80, type: 'ground' },
            { x: 3300, y: 560, w: 300, h: 80, type: 'ground' },

            // Moving platform indicators (rendered as wood)
            { x: 320, y: 450, w: 80, h: 20, type: 'wood', moving: true, moveX: 100 },
            { x: 600, y: 380, w: 80, h: 20, type: 'wood', moving: true, moveY: 80 },
            { x: 1180, y: 400, w: 100, h: 20, type: 'wood', moving: true, moveX: 120 },
            { x: 1560, y: 350, w: 80, h: 20, type: 'wood', moving: true, moveY: 100 },
            { x: 2550, y: 380, w: 100, h: 20, type: 'wood', moving: true, moveX: 80 },

            // Static platforms
            { x: 150, y: 420, w: 100, h: 25, type: 'wood' },
            { x: 480, y: 480, w: 80, h: 20, type: 'wood' },
            { x: 750, y: 400, w: 120, h: 25, type: 'wood' },
            { x: 920, y: 320, w: 100, h: 25, type: 'wood' },
            { x: 1100, y: 280, w: 80, h: 20, type: 'wood' },
            { x: 1350, y: 380, w: 120, h: 25, type: 'wood' },
            { x: 1700, y: 420, w: 100, h: 25, type: 'wood' },
            { x: 1850, y: 340, w: 80, h: 20, type: 'wood' },
            { x: 2050, y: 400, w: 120, h: 25, type: 'wood' },
            { x: 2380, y: 380, w: 100, h: 25, type: 'wood' },
            { x: 2750, y: 420, w: 80, h: 20, type: 'wood' },
            { x: 3100, y: 380, w: 120, h: 25, type: 'wood' },

            // Boss arena
            { x: 3200, y: 450, w: 350, h: 30, type: 'stone' },
        ],

        checkpoints: [
            { x: 100, y: 520, id: 0 },
            { x: 1300, y: 520, id: 1 },
            { x: 2500, y: 520, id: 2 }
        ],

        treasures: [
            { x: 180, y: 390, type: 'coin' }, { x: 350, y: 420, type: 'coin' },
            { x: 500, y: 450, type: 'coin' }, { x: 680, y: 530, type: 'coin' },
            { x: 780, y: 370, type: 'gem' }, { x: 950, y: 290, type: 'coin' },
            { x: 1130, y: 250, type: 'gem' }, { x: 1380, y: 350, type: 'coin' },
            { x: 1650, y: 530, type: 'coin' }, { x: 1730, y: 390, type: 'coin' },
            { x: 1880, y: 310, type: 'gem' }, { x: 2080, y: 370, type: 'coin' },
            { x: 2260, y: 530, type: 'coin' }, { x: 2410, y: 350, type: 'coin' },
            { x: 2630, y: 530, type: 'gem' }, { x: 2780, y: 390, type: 'coin' },
            { x: 2920, y: 530, type: 'coin' }, { x: 3130, y: 350, type: 'gem' },
            { x: 600, y: 530, type: 'health' },
            { x: 1500, y: 530, type: 'health' },
            { x: 2400, y: 530, type: 'health' },
        ],

        enemies: [
            { x: 420, y: 510, type: 'skeleton', patrolStart: 380, patrolEnd: 580 },
            { x: 700, y: 510, type: 'skeleton', patrolStart: 650, patrolEnd: 900 },
            { x: 1050, y: 510, type: 'skeleton', patrolStart: 980, patrolEnd: 1160 },
            { x: 1300, y: 510, type: 'skeleton', patrolStart: 1240, patrolEnd: 1540 },
            { x: 1680, y: 510, type: 'skeleton', patrolStart: 1620, patrolEnd: 1820 },
            { x: 2000, y: 510, type: 'skeleton', patrolStart: 1900, patrolEnd: 2150 },
            { x: 2300, y: 510, type: 'skeleton', patrolStart: 2230, patrolEnd: 2530 },
            { x: 2660, y: 510, type: 'skeleton', patrolStart: 2600, patrolEnd: 2800 },
            // Ghosts
            { x: 500, y: 380, type: 'ghost', patrolStart: 450, patrolEnd: 600 },
            { x: 850, y: 300, type: 'ghost', patrolStart: 750, patrolEnd: 950 },
            { x: 1400, y: 320, type: 'ghost', patrolStart: 1300, patrolEnd: 1500 },
            { x: 2100, y: 340, type: 'ghost', patrolStart: 2000, patrolEnd: 2200 },
            { x: 2800, y: 360, type: 'ghost', patrolStart: 2700, patrolEnd: 2900 },
            // Boss
            { x: 3350, y: 380, type: 'boss_spider' }
        ],

        powerups: [
            { x: 950, y: 290, type: 'speedBoost' },
            { x: 2100, y: 370, type: 'shield' },
        ],

        hazards: [
            { x: 300, y: 555, w: 80, h: 10, type: 'spikes' },
            { x: 580, y: 555, w: 70, h: 10, type: 'spikes' },
            { x: 1160, y: 555, w: 80, h: 10, type: 'spikes' },
        ],

        decorations: []
    },

    // LEVEL 3: Crystal Caves
    3: {
        name: 'Crystal Caves',
        theme: 'caves',
        width: 3800,
        height: 640,
        parTime: 220,
        playerStart: { x: 100, y: 400 },

        platforms: [
            // Ground sections
            { x: 0, y: 560, w: 350, h: 80, type: 'ground' },
            { x: 420, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 700, y: 560, w: 280, h: 80, type: 'ground' },
            { x: 1060, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 1340, y: 560, w: 350, h: 80, type: 'ground' },
            { x: 1770, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 2050, y: 560, w: 280, h: 80, type: 'ground' },
            { x: 2410, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 2690, y: 560, w: 350, h: 80, type: 'ground' },
            { x: 3120, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 3400, y: 560, w: 400, h: 80, type: 'ground' },

            // Crystal platforms (crumbling type)
            { x: 370, y: 480, w: 60, h: 20, type: 'crystal', crumbling: true },
            { x: 640, y: 420, w: 60, h: 20, type: 'crystal', crumbling: true },
            { x: 1000, y: 450, w: 60, h: 20, type: 'crystal', crumbling: true },
            { x: 1280, y: 400, w: 60, h: 20, type: 'crystal', crumbling: true },
            { x: 1710, y: 480, w: 60, h: 20, type: 'crystal', crumbling: true },
            { x: 1990, y: 420, w: 60, h: 20, type: 'crystal', crumbling: true },
            { x: 2350, y: 450, w: 60, h: 20, type: 'crystal', crumbling: true },
            { x: 2630, y: 400, w: 60, h: 20, type: 'crystal', crumbling: true },
            { x: 3060, y: 480, w: 60, h: 20, type: 'crystal', crumbling: true },

            // Stable stone platforms
            { x: 200, y: 450, w: 120, h: 25, type: 'stone' },
            { x: 500, y: 380, w: 100, h: 25, type: 'stone' },
            { x: 780, y: 420, w: 150, h: 25, type: 'stone' },
            { x: 1120, y: 350, w: 100, h: 25, type: 'stone' },
            { x: 1450, y: 400, w: 120, h: 25, type: 'stone' },
            { x: 1600, y: 320, w: 100, h: 25, type: 'stone' },
            { x: 1870, y: 380, w: 100, h: 25, type: 'stone' },
            { x: 2150, y: 350, w: 120, h: 25, type: 'stone' },
            { x: 2500, y: 380, w: 100, h: 25, type: 'stone' },
            { x: 2800, y: 420, w: 150, h: 25, type: 'stone' },
            { x: 3000, y: 350, w: 100, h: 25, type: 'stone' },
            { x: 3200, y: 300, w: 120, h: 25, type: 'stone' },

            // Boss arena
            { x: 3400, y: 450, w: 350, h: 30, type: 'stone' },
        ],

        checkpoints: [
            { x: 100, y: 520, id: 0 },
            { x: 1400, y: 520, id: 1 },
            { x: 2750, y: 520, id: 2 }
        ],

        treasures: [
            { x: 230, y: 420, type: 'coin' }, { x: 400, y: 450, type: 'gem' },
            { x: 530, y: 350, type: 'coin' }, { x: 670, y: 390, type: 'coin' },
            { x: 810, y: 390, type: 'gem' }, { x: 1030, y: 420, type: 'coin' },
            { x: 1150, y: 320, type: 'coin' }, { x: 1310, y: 370, type: 'gem' },
            { x: 1480, y: 370, type: 'coin' }, { x: 1630, y: 290, type: 'coin' },
            { x: 1740, y: 450, type: 'gem' }, { x: 1900, y: 350, type: 'coin' },
            { x: 2020, y: 390, type: 'coin' }, { x: 2180, y: 320, type: 'gem' },
            { x: 2380, y: 420, type: 'coin' }, { x: 2530, y: 350, type: 'coin' },
            { x: 2660, y: 370, type: 'gem' }, { x: 2830, y: 390, type: 'coin' },
            { x: 3030, y: 320, type: 'coin' }, { x: 3230, y: 270, type: 'gem' },
            { x: 3550, y: 400, type: 'chest' },
            { x: 750, y: 530, type: 'health' },
            { x: 1800, y: 530, type: 'health' },
            { x: 2900, y: 530, type: 'health' },
        ],

        enemies: [
            { x: 480, y: 510, type: 'skeleton', patrolStart: 420, patrolEnd: 620 },
            { x: 800, y: 510, type: 'skeleton', patrolStart: 700, patrolEnd: 980 },
            { x: 1150, y: 510, type: 'skeleton', patrolStart: 1060, patrolEnd: 1260 },
            { x: 1500, y: 510, type: 'skeleton', patrolStart: 1340, patrolEnd: 1690 },
            { x: 1870, y: 510, type: 'skeleton', patrolStart: 1770, patrolEnd: 1970 },
            { x: 2200, y: 510, type: 'skeleton', patrolStart: 2050, patrolEnd: 2330 },
            { x: 2550, y: 510, type: 'skeleton', patrolStart: 2410, patrolEnd: 2610 },
            { x: 2850, y: 510, type: 'skeleton', patrolStart: 2690, patrolEnd: 3040 },
            { x: 3250, y: 510, type: 'skeleton', patrolStart: 3120, patrolEnd: 3320 },
            // Cave bats (ghosts reskinned)
            { x: 600, y: 320, type: 'ghost', patrolStart: 500, patrolEnd: 700 },
            { x: 1200, y: 280, type: 'ghost', patrolStart: 1100, patrolEnd: 1300 },
            { x: 1750, y: 300, type: 'ghost', patrolStart: 1650, patrolEnd: 1850 },
            { x: 2400, y: 280, type: 'ghost', patrolStart: 2300, patrolEnd: 2500 },
            { x: 3100, y: 280, type: 'ghost', patrolStart: 3000, patrolEnd: 3200 },
            // Boss
            { x: 3550, y: 380, type: 'boss_golem' }
        ],

        powerups: [
            { x: 1150, y: 320, type: 'doubleJump' },
            { x: 2500, y: 350, type: 'magnet' },
        ],

        hazards: [
            { x: 350, y: 555, w: 70, h: 10, type: 'spikes' },
            { x: 620, y: 555, w: 80, h: 10, type: 'spikes' },
            { x: 980, y: 555, w: 80, h: 10, type: 'spikes' },
            { x: 1260, y: 555, w: 80, h: 10, type: 'spikes' },
            { x: 1690, y: 555, w: 80, h: 10, type: 'spikes' },
            { x: 1970, y: 555, w: 80, h: 10, type: 'spikes' },
            { x: 2330, y: 555, w: 80, h: 10, type: 'spikes' },
            { x: 2610, y: 555, w: 80, h: 10, type: 'spikes' },
            { x: 3040, y: 555, w: 80, h: 10, type: 'spikes' },
        ],

        decorations: []
    },

    // LEVEL 4: Sunken Temple
    4: {
        name: 'Sunken Temple',
        theme: 'temple',
        width: 4000,
        height: 640,
        parTime: 240,
        playerStart: { x: 100, y: 400 },

        platforms: [
            // Ground sections with water gaps
            { x: 0, y: 560, w: 300, h: 80, type: 'ground' },
            { x: 400, y: 560, w: 250, h: 80, type: 'ground' },
            { x: 750, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 1050, y: 560, w: 300, h: 80, type: 'ground' },
            { x: 1450, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 1750, y: 560, w: 250, h: 80, type: 'ground' },
            { x: 2100, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 2400, y: 560, w: 300, h: 80, type: 'ground' },
            { x: 2800, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 3100, y: 560, w: 250, h: 80, type: 'ground' },
            { x: 3450, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 3750, y: 560, w: 250, h: 80, type: 'ground' },

            // Temple stone platforms
            { x: 150, y: 450, w: 120, h: 25, type: 'stone' },
            { x: 320, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 500, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 680, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 850, y: 420, w: 120, h: 25, type: 'stone' },
            { x: 1000, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 1200, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 1380, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 1550, y: 420, w: 120, h: 25, type: 'stone' },
            { x: 1700, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 1900, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 2050, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 2250, y: 420, w: 120, h: 25, type: 'stone' },
            { x: 2450, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 2600, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 2750, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 2950, y: 420, w: 120, h: 25, type: 'stone' },
            { x: 3150, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 3350, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 3550, y: 380, w: 80, h: 20, type: 'stone' },

            // Boss arena
            { x: 3750, y: 450, w: 250, h: 30, type: 'stone' },
        ],

        checkpoints: [
            { x: 100, y: 520, id: 0 },
            { x: 1500, y: 520, id: 1 },
            { x: 2900, y: 520, id: 2 }
        ],

        treasures: [
            { x: 180, y: 420, type: 'coin' }, { x: 350, y: 350, type: 'coin' },
            { x: 530, y: 420, type: 'gem' }, { x: 710, y: 350, type: 'coin' },
            { x: 880, y: 390, type: 'coin' }, { x: 1030, y: 320, type: 'gem' },
            { x: 1230, y: 420, type: 'coin' }, { x: 1410, y: 350, type: 'coin' },
            { x: 1580, y: 390, type: 'gem' }, { x: 1730, y: 320, type: 'coin' },
            { x: 1930, y: 420, type: 'coin' }, { x: 2080, y: 350, type: 'gem' },
            { x: 2280, y: 390, type: 'coin' }, { x: 2480, y: 320, type: 'coin' },
            { x: 2630, y: 420, type: 'gem' }, { x: 2780, y: 350, type: 'coin' },
            { x: 2980, y: 390, type: 'coin' }, { x: 3180, y: 320, type: 'gem' },
            { x: 3380, y: 420, type: 'coin' }, { x: 3580, y: 350, type: 'gem' },
            { x: 3850, y: 400, type: 'chest' },
            { x: 800, y: 530, type: 'health' },
            { x: 1800, y: 530, type: 'health' },
            { x: 2850, y: 530, type: 'health' },
        ],

        enemies: [
            { x: 450, y: 510, type: 'skeleton', patrolStart: 400, patrolEnd: 650 },
            { x: 850, y: 510, type: 'skeleton', patrolStart: 750, patrolEnd: 950 },
            { x: 1200, y: 510, type: 'skeleton', patrolStart: 1050, patrolEnd: 1350 },
            { x: 1550, y: 510, type: 'skeleton', patrolStart: 1450, patrolEnd: 1650 },
            { x: 1900, y: 510, type: 'skeleton', patrolStart: 1750, patrolEnd: 2000 },
            { x: 2300, y: 510, type: 'skeleton', patrolStart: 2100, patrolEnd: 2300 },
            { x: 2600, y: 510, type: 'skeleton', patrolStart: 2400, patrolEnd: 2700 },
            { x: 2950, y: 510, type: 'skeleton', patrolStart: 2800, patrolEnd: 3000 },
            { x: 3250, y: 510, type: 'skeleton', patrolStart: 3100, patrolEnd: 3350 },
            { x: 3550, y: 510, type: 'skeleton', patrolStart: 3450, patrolEnd: 3650 },
            // Ghost fish
            { x: 400, y: 350, type: 'ghost', patrolStart: 300, patrolEnd: 500 },
            { x: 900, y: 300, type: 'ghost', patrolStart: 800, patrolEnd: 1000 },
            { x: 1400, y: 300, type: 'ghost', patrolStart: 1300, patrolEnd: 1500 },
            { x: 2000, y: 320, type: 'ghost', patrolStart: 1900, patrolEnd: 2100 },
            { x: 2550, y: 300, type: 'ghost', patrolStart: 2450, patrolEnd: 2650 },
            { x: 3100, y: 280, type: 'ghost', patrolStart: 3000, patrolEnd: 3200 },
            // Boss
            { x: 3850, y: 350, type: 'boss_serpent' }
        ],

        powerups: [
            { x: 1000, y: 320, type: 'shield' },
            { x: 2200, y: 390, type: 'speedBoost' },
            { x: 3200, y: 320, type: 'fury' },
        ],

        hazards: [
            { x: 300, y: 560, w: 100, h: 80, type: 'water' },
            { x: 650, y: 560, w: 100, h: 80, type: 'water' },
            { x: 950, y: 560, w: 100, h: 80, type: 'water' },
            { x: 1350, y: 560, w: 100, h: 80, type: 'water' },
            { x: 1650, y: 560, w: 100, h: 80, type: 'water' },
            { x: 2000, y: 560, w: 100, h: 80, type: 'water' },
            { x: 2300, y: 560, w: 100, h: 80, type: 'water' },
            { x: 2700, y: 560, w: 100, h: 80, type: 'water' },
            { x: 3000, y: 560, w: 100, h: 80, type: 'water' },
            { x: 3350, y: 560, w: 100, h: 80, type: 'water' },
        ],

        decorations: []
    },

    // LEVEL 5: Volcanic Depths
    5: {
        name: 'Volcanic Depths',
        theme: 'volcano',
        width: 4200,
        height: 640,
        parTime: 260,
        playerStart: { x: 100, y: 400 },

        platforms: [
            // Ground sections over lava
            { x: 0, y: 560, w: 280, h: 80, type: 'ground' },
            { x: 380, y: 560, w: 220, h: 80, type: 'ground' },
            { x: 700, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 1000, y: 560, w: 280, h: 80, type: 'ground' },
            { x: 1380, y: 560, w: 220, h: 80, type: 'ground' },
            { x: 1700, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 2000, y: 560, w: 280, h: 80, type: 'ground' },
            { x: 2380, y: 560, w: 220, h: 80, type: 'ground' },
            { x: 2700, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 3000, y: 560, w: 280, h: 80, type: 'ground' },
            { x: 3380, y: 560, w: 220, h: 80, type: 'ground' },
            { x: 3700, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 4000, y: 560, w: 200, h: 80, type: 'ground' },

            // Stone platforms
            { x: 150, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 300, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 480, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 650, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 800, y: 420, w: 100, h: 25, type: 'stone' },
            { x: 1100, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 1250, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 1450, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 1600, y: 420, w: 100, h: 25, type: 'stone' },
            { x: 1800, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 1950, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 2150, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 2300, y: 420, w: 100, h: 25, type: 'stone' },
            { x: 2500, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 2650, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 2850, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 3050, y: 420, w: 100, h: 25, type: 'stone' },
            { x: 3250, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 3450, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 3650, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 3850, y: 350, w: 100, h: 25, type: 'stone' },

            // Boss arena
            { x: 4000, y: 450, w: 180, h: 30, type: 'stone' },
        ],

        checkpoints: [
            { x: 100, y: 520, id: 0 },
            { x: 1500, y: 520, id: 1 },
            { x: 3100, y: 520, id: 2 }
        ],

        treasures: [
            { x: 180, y: 420, type: 'coin' }, { x: 330, y: 350, type: 'coin' },
            { x: 510, y: 420, type: 'gem' }, { x: 680, y: 350, type: 'coin' },
            { x: 830, y: 390, type: 'coin' }, { x: 1130, y: 320, type: 'gem' },
            { x: 1280, y: 420, type: 'coin' }, { x: 1480, y: 350, type: 'coin' },
            { x: 1630, y: 390, type: 'gem' }, { x: 1830, y: 320, type: 'coin' },
            { x: 1980, y: 420, type: 'coin' }, { x: 2180, y: 350, type: 'gem' },
            { x: 2330, y: 390, type: 'coin' }, { x: 2530, y: 320, type: 'coin' },
            { x: 2680, y: 420, type: 'gem' }, { x: 2880, y: 350, type: 'coin' },
            { x: 3080, y: 390, type: 'coin' }, { x: 3280, y: 320, type: 'gem' },
            { x: 3480, y: 420, type: 'coin' }, { x: 3680, y: 350, type: 'coin' },
            { x: 3880, y: 320, type: 'gem' }, { x: 4080, y: 400, type: 'chest' },
            { x: 850, y: 530, type: 'health' },
            { x: 1900, y: 530, type: 'health' },
            { x: 3050, y: 530, type: 'health' },
        ],

        enemies: [
            { x: 430, y: 510, type: 'skeleton', patrolStart: 380, patrolEnd: 600 },
            { x: 800, y: 510, type: 'skeleton', patrolStart: 700, patrolEnd: 900 },
            { x: 1150, y: 510, type: 'skeleton', patrolStart: 1000, patrolEnd: 1280 },
            { x: 1500, y: 510, type: 'skeleton', patrolStart: 1380, patrolEnd: 1600 },
            { x: 1850, y: 510, type: 'skeleton', patrolStart: 1700, patrolEnd: 1900 },
            { x: 2150, y: 510, type: 'skeleton', patrolStart: 2000, patrolEnd: 2280 },
            { x: 2500, y: 510, type: 'skeleton', patrolStart: 2380, patrolEnd: 2600 },
            { x: 2850, y: 510, type: 'skeleton', patrolStart: 2700, patrolEnd: 2900 },
            { x: 3150, y: 510, type: 'skeleton', patrolStart: 3000, patrolEnd: 3280 },
            { x: 3500, y: 510, type: 'skeleton', patrolStart: 3380, patrolEnd: 3600 },
            { x: 3850, y: 510, type: 'skeleton', patrolStart: 3700, patrolEnd: 3900 },
            // Fire ghosts
            { x: 500, y: 320, type: 'ghost', patrolStart: 400, patrolEnd: 600 },
            { x: 1200, y: 280, type: 'ghost', patrolStart: 1100, patrolEnd: 1300 },
            { x: 1900, y: 300, type: 'ghost', patrolStart: 1800, patrolEnd: 2000 },
            { x: 2600, y: 280, type: 'ghost', patrolStart: 2500, patrolEnd: 2700 },
            { x: 3300, y: 280, type: 'ghost', patrolStart: 3200, patrolEnd: 3400 },
            // Boss
            { x: 4080, y: 380, type: 'boss_demon' }
        ],

        powerups: [
            { x: 1100, y: 320, type: 'shield' },
            { x: 2200, y: 350, type: 'speedBoost' },
            { x: 3300, y: 320, type: 'fury' },
        ],

        hazards: [
            { x: 280, y: 560, w: 100, h: 80, type: 'lava', rising: true },
            { x: 600, y: 560, w: 100, h: 80, type: 'lava' },
            { x: 900, y: 560, w: 100, h: 80, type: 'lava', rising: true },
            { x: 1280, y: 560, w: 100, h: 80, type: 'lava' },
            { x: 1600, y: 560, w: 100, h: 80, type: 'lava', rising: true },
            { x: 1900, y: 560, w: 100, h: 80, type: 'lava' },
            { x: 2280, y: 560, w: 100, h: 80, type: 'lava', rising: true },
            { x: 2600, y: 560, w: 100, h: 80, type: 'lava' },
            { x: 2900, y: 560, w: 100, h: 80, type: 'lava', rising: true },
            { x: 3280, y: 560, w: 100, h: 80, type: 'lava' },
            { x: 3600, y: 560, w: 100, h: 80, type: 'lava', rising: true },
            { x: 3900, y: 560, w: 100, h: 80, type: 'lava' },
        ],

        decorations: []
    },

    // LEVEL 6: Ancient Ruins
    6: {
        name: 'Ancient Ruins',
        theme: 'ruins',
        width: 4400,
        height: 640,
        parTime: 280,
        playerStart: { x: 100, y: 400 },

        platforms: [
            // Ground sections
            { x: 0, y: 560, w: 300, h: 80, type: 'ground' },
            { x: 400, y: 560, w: 250, h: 80, type: 'ground' },
            { x: 750, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 1050, y: 560, w: 300, h: 80, type: 'ground' },
            { x: 1450, y: 560, w: 250, h: 80, type: 'ground' },
            { x: 1800, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 2100, y: 560, w: 300, h: 80, type: 'ground' },
            { x: 2500, y: 560, w: 250, h: 80, type: 'ground' },
            { x: 2850, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 3150, y: 560, w: 300, h: 80, type: 'ground' },
            { x: 3550, y: 560, w: 250, h: 80, type: 'ground' },
            { x: 3900, y: 560, w: 200, h: 80, type: 'ground' },
            { x: 4200, y: 560, w: 200, h: 80, type: 'ground' },

            // Ruin stone platforms
            { x: 150, y: 450, w: 120, h: 25, type: 'stone' },
            { x: 320, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 500, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 700, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 900, y: 320, w: 120, h: 25, type: 'stone' },
            { x: 1150, y: 420, w: 100, h: 25, type: 'stone' },
            { x: 1350, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 1550, y: 420, w: 100, h: 25, type: 'stone' },
            { x: 1750, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 1950, y: 280, w: 120, h: 25, type: 'stone' },
            { x: 2200, y: 420, w: 100, h: 25, type: 'stone' },
            { x: 2400, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 2600, y: 420, w: 100, h: 25, type: 'stone' },
            { x: 2800, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 3000, y: 280, w: 120, h: 25, type: 'stone' },
            { x: 3250, y: 420, w: 100, h: 25, type: 'stone' },
            { x: 3450, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 3650, y: 420, w: 100, h: 25, type: 'stone' },
            { x: 3850, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 4050, y: 300, w: 120, h: 25, type: 'stone' },

            // Boss arena
            { x: 4200, y: 450, w: 180, h: 30, type: 'stone' },
        ],

        checkpoints: [
            { x: 100, y: 520, id: 0 },
            { x: 1600, y: 520, id: 1 },
            { x: 3200, y: 520, id: 2 }
        ],

        treasures: [
            { x: 180, y: 420, type: 'coin' }, { x: 350, y: 350, type: 'coin' },
            { x: 530, y: 420, type: 'gem' }, { x: 730, y: 350, type: 'coin' },
            { x: 930, y: 290, type: 'gem' }, { x: 1180, y: 390, type: 'coin' },
            { x: 1380, y: 320, type: 'coin' }, { x: 1580, y: 390, type: 'gem' },
            { x: 1780, y: 320, type: 'coin' }, { x: 1980, y: 250, type: 'gem' },
            { x: 2230, y: 390, type: 'coin' }, { x: 2430, y: 320, type: 'coin' },
            { x: 2630, y: 390, type: 'gem' }, { x: 2830, y: 320, type: 'coin' },
            { x: 3030, y: 250, type: 'gem' }, { x: 3280, y: 390, type: 'coin' },
            { x: 3480, y: 320, type: 'coin' }, { x: 3680, y: 390, type: 'gem' },
            { x: 3880, y: 320, type: 'coin' }, { x: 4080, y: 270, type: 'gem' },
            { x: 4280, y: 400, type: 'chest' },
            { x: 900, y: 530, type: 'health' },
            { x: 2000, y: 530, type: 'health' },
            { x: 3200, y: 530, type: 'health' },
        ],

        enemies: [
            { x: 450, y: 510, type: 'skeleton', patrolStart: 400, patrolEnd: 650 },
            { x: 850, y: 510, type: 'skeleton', patrolStart: 750, patrolEnd: 950 },
            { x: 1200, y: 510, type: 'skeleton', patrolStart: 1050, patrolEnd: 1350 },
            { x: 1550, y: 510, type: 'skeleton', patrolStart: 1450, patrolEnd: 1700 },
            { x: 1950, y: 510, type: 'skeleton', patrolStart: 1800, patrolEnd: 2000 },
            { x: 2300, y: 510, type: 'skeleton', patrolStart: 2100, patrolEnd: 2400 },
            { x: 2650, y: 510, type: 'skeleton', patrolStart: 2500, patrolEnd: 2750 },
            { x: 3000, y: 510, type: 'skeleton', patrolStart: 2850, patrolEnd: 3050 },
            { x: 3350, y: 510, type: 'skeleton', patrolStart: 3150, patrolEnd: 3450 },
            { x: 3700, y: 510, type: 'skeleton', patrolStart: 3550, patrolEnd: 3800 },
            { x: 4050, y: 510, type: 'skeleton', patrolStart: 3900, patrolEnd: 4100 },
            // Stone spirits (ghosts)
            { x: 600, y: 320, type: 'ghost', patrolStart: 500, patrolEnd: 700 },
            { x: 1100, y: 280, type: 'ghost', patrolStart: 1000, patrolEnd: 1200 },
            { x: 1700, y: 300, type: 'ghost', patrolStart: 1600, patrolEnd: 1800 },
            { x: 2350, y: 280, type: 'ghost', patrolStart: 2250, patrolEnd: 2450 },
            { x: 2900, y: 260, type: 'ghost', patrolStart: 2800, patrolEnd: 3000 },
            { x: 3550, y: 280, type: 'ghost', patrolStart: 3450, patrolEnd: 3650 },
            // Boss
            { x: 4280, y: 380, type: 'boss_guardian' }
        ],

        powerups: [
            { x: 930, y: 290, type: 'doubleJump' },
            { x: 1980, y: 250, type: 'shield' },
            { x: 3030, y: 250, type: 'fury' },
        ],

        hazards: [
            { x: 300, y: 540, w: 100, h: 60, type: 'wind', direction: 1 },
            { x: 650, y: 540, w: 100, h: 60, type: 'wind', direction: -1 },
            { x: 950, y: 540, w: 100, h: 60, type: 'wind', direction: 1 },
            { x: 1350, y: 540, w: 100, h: 60, type: 'wind', direction: -1 },
            { x: 1700, y: 540, w: 100, h: 60, type: 'wind', direction: 1 },
            { x: 2000, y: 540, w: 100, h: 60, type: 'wind', direction: -1 },
            { x: 2400, y: 540, w: 100, h: 60, type: 'wind', direction: 1 },
            { x: 2750, y: 540, w: 100, h: 60, type: 'wind', direction: -1 },
            { x: 3050, y: 540, w: 100, h: 60, type: 'wind', direction: 1 },
            { x: 3450, y: 540, w: 100, h: 60, type: 'wind', direction: -1 },
            { x: 3800, y: 540, w: 100, h: 60, type: 'wind', direction: 1 },
        ],

        decorations: []
    },

    // LEVEL 7: Sky Temple (Final)
    7: {
        name: 'Sky Temple',
        theme: 'sky',
        width: 4600,
        height: 640,
        parTime: 300,
        playerStart: { x: 100, y: 400 },

        platforms: [
            // Cloud ground sections
            { x: 0, y: 560, w: 250, h: 80, type: 'cloud' },
            { x: 350, y: 560, w: 200, h: 80, type: 'cloud' },
            { x: 650, y: 560, w: 200, h: 80, type: 'cloud' },
            { x: 950, y: 560, w: 250, h: 80, type: 'cloud' },
            { x: 1300, y: 560, w: 200, h: 80, type: 'cloud' },
            { x: 1600, y: 560, w: 200, h: 80, type: 'cloud' },
            { x: 1900, y: 560, w: 250, h: 80, type: 'cloud' },
            { x: 2250, y: 560, w: 200, h: 80, type: 'cloud' },
            { x: 2550, y: 560, w: 200, h: 80, type: 'cloud' },
            { x: 2850, y: 560, w: 250, h: 80, type: 'cloud' },
            { x: 3200, y: 560, w: 200, h: 80, type: 'cloud' },
            { x: 3500, y: 560, w: 200, h: 80, type: 'cloud' },
            { x: 3800, y: 560, w: 250, h: 80, type: 'cloud' },
            { x: 4150, y: 560, w: 200, h: 80, type: 'cloud' },
            { x: 4450, y: 560, w: 150, h: 80, type: 'ground' },

            // Temporary cloud platforms (fade after stepping)
            { x: 270, y: 480, w: 80, h: 20, type: 'cloudTemp', fadeTime: 90 },
            { x: 570, y: 420, w: 80, h: 20, type: 'cloudTemp', fadeTime: 90 },
            { x: 870, y: 380, w: 80, h: 20, type: 'cloudTemp', fadeTime: 90 },
            { x: 1220, y: 450, w: 80, h: 20, type: 'cloudTemp', fadeTime: 90 },
            { x: 1520, y: 400, w: 80, h: 20, type: 'cloudTemp', fadeTime: 90 },
            { x: 1820, y: 350, w: 80, h: 20, type: 'cloudTemp', fadeTime: 90 },
            { x: 2170, y: 450, w: 80, h: 20, type: 'cloudTemp', fadeTime: 90 },
            { x: 2470, y: 400, w: 80, h: 20, type: 'cloudTemp', fadeTime: 90 },
            { x: 2770, y: 350, w: 80, h: 20, type: 'cloudTemp', fadeTime: 90 },
            { x: 3120, y: 450, w: 80, h: 20, type: 'cloudTemp', fadeTime: 90 },
            { x: 3420, y: 400, w: 80, h: 20, type: 'cloudTemp', fadeTime: 90 },
            { x: 3720, y: 350, w: 80, h: 20, type: 'cloudTemp', fadeTime: 90 },
            { x: 4070, y: 450, w: 80, h: 20, type: 'cloudTemp', fadeTime: 90 },

            // Stable golden platforms
            { x: 150, y: 420, w: 100, h: 25, type: 'stone' },
            { x: 400, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 700, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 1000, y: 380, w: 80, h: 20, type: 'stone' },
            { x: 1100, y: 280, w: 100, h: 25, type: 'stone' },
            { x: 1350, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 1650, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 1950, y: 280, w: 80, h: 20, type: 'stone' },
            { x: 2050, y: 380, w: 100, h: 25, type: 'stone' },
            { x: 2300, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 2600, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 2900, y: 280, w: 80, h: 20, type: 'stone' },
            { x: 3000, y: 380, w: 100, h: 25, type: 'stone' },
            { x: 3250, y: 350, w: 80, h: 20, type: 'stone' },
            { x: 3550, y: 450, w: 100, h: 25, type: 'stone' },
            { x: 3850, y: 280, w: 80, h: 20, type: 'stone' },
            { x: 4000, y: 350, w: 100, h: 25, type: 'stone' },
            { x: 4250, y: 400, w: 80, h: 20, type: 'stone' },

            // Boss arena
            { x: 4400, y: 450, w: 200, h: 30, type: 'stone' },
        ],

        checkpoints: [
            { x: 100, y: 520, id: 0 },
            { x: 1700, y: 520, id: 1 },
            { x: 3400, y: 520, id: 2 }
        ],

        treasures: [
            { x: 180, y: 390, type: 'coin' }, { x: 300, y: 450, type: 'coin' },
            { x: 430, y: 320, type: 'gem' }, { x: 600, y: 390, type: 'coin' },
            { x: 730, y: 420, type: 'coin' }, { x: 900, y: 350, type: 'gem' },
            { x: 1030, y: 350, type: 'coin' }, { x: 1130, y: 250, type: 'gem' },
            { x: 1250, y: 420, type: 'coin' }, { x: 1380, y: 320, type: 'coin' },
            { x: 1550, y: 370, type: 'gem' }, { x: 1680, y: 420, type: 'coin' },
            { x: 1850, y: 320, type: 'coin' }, { x: 1980, y: 250, type: 'gem' },
            { x: 2080, y: 350, type: 'coin' }, { x: 2200, y: 420, type: 'coin' },
            { x: 2330, y: 320, type: 'gem' }, { x: 2500, y: 370, type: 'coin' },
            { x: 2630, y: 420, type: 'coin' }, { x: 2800, y: 320, type: 'gem' },
            { x: 2930, y: 250, type: 'gem' }, { x: 3030, y: 350, type: 'coin' },
            { x: 3150, y: 420, type: 'coin' }, { x: 3280, y: 320, type: 'gem' },
            { x: 3450, y: 370, type: 'coin' }, { x: 3580, y: 420, type: 'coin' },
            { x: 3750, y: 320, type: 'gem' }, { x: 3880, y: 250, type: 'gem' },
            { x: 4030, y: 320, type: 'coin' }, { x: 4280, y: 370, type: 'gem' },
            { x: 4480, y: 400, type: 'chest' },
            { x: 1000, y: 530, type: 'health' },
            { x: 2100, y: 530, type: 'health' },
            { x: 3300, y: 530, type: 'health' },
            { x: 4200, y: 530, type: 'health' },
        ],

        enemies: [
            { x: 400, y: 510, type: 'skeleton', patrolStart: 350, patrolEnd: 550 },
            { x: 750, y: 510, type: 'skeleton', patrolStart: 650, patrolEnd: 850 },
            { x: 1100, y: 510, type: 'skeleton', patrolStart: 950, patrolEnd: 1200 },
            { x: 1450, y: 510, type: 'skeleton', patrolStart: 1300, patrolEnd: 1500 },
            { x: 1750, y: 510, type: 'skeleton', patrolStart: 1600, patrolEnd: 1800 },
            { x: 2100, y: 510, type: 'skeleton', patrolStart: 1900, patrolEnd: 2150 },
            { x: 2400, y: 510, type: 'skeleton', patrolStart: 2250, patrolEnd: 2450 },
            { x: 2700, y: 510, type: 'skeleton', patrolStart: 2550, patrolEnd: 2750 },
            { x: 3000, y: 510, type: 'skeleton', patrolStart: 2850, patrolEnd: 3100 },
            { x: 3350, y: 510, type: 'skeleton', patrolStart: 3200, patrolEnd: 3400 },
            { x: 3650, y: 510, type: 'skeleton', patrolStart: 3500, patrolEnd: 3700 },
            { x: 3950, y: 510, type: 'skeleton', patrolStart: 3800, patrolEnd: 4050 },
            { x: 4250, y: 510, type: 'skeleton', patrolStart: 4150, patrolEnd: 4350 },
            // Sky spirits (ghosts)
            { x: 350, y: 300, type: 'ghost', patrolStart: 250, patrolEnd: 450 },
            { x: 800, y: 320, type: 'ghost', patrolStart: 700, patrolEnd: 900 },
            { x: 1200, y: 250, type: 'ghost', patrolStart: 1100, patrolEnd: 1300 },
            { x: 1600, y: 300, type: 'ghost', patrolStart: 1500, patrolEnd: 1700 },
            { x: 2050, y: 260, type: 'ghost', patrolStart: 1950, patrolEnd: 2150 },
            { x: 2500, y: 300, type: 'ghost', patrolStart: 2400, patrolEnd: 2600 },
            { x: 2950, y: 240, type: 'ghost', patrolStart: 2850, patrolEnd: 3050 },
            { x: 3400, y: 280, type: 'ghost', patrolStart: 3300, patrolEnd: 3500 },
            { x: 3900, y: 260, type: 'ghost', patrolStart: 3800, patrolEnd: 4000 },
            // Final Boss
            { x: 4480, y: 350, type: 'boss_sorcerer' }
        ],

        powerups: [
            { x: 1130, y: 250, type: 'doubleJump' },
            { x: 1980, y: 250, type: 'shield' },
            { x: 2930, y: 250, type: 'speedBoost' },
            { x: 3880, y: 250, type: 'fury' },
        ],

        hazards: [
            // Bottomless pits - fall damage handled by level design
            { x: 250, y: 560, w: 100, h: 80, type: 'pit' },
            { x: 550, y: 560, w: 100, h: 80, type: 'pit' },
            { x: 850, y: 560, w: 100, h: 80, type: 'pit' },
            { x: 1200, y: 560, w: 100, h: 80, type: 'pit' },
            { x: 1500, y: 560, w: 100, h: 80, type: 'pit' },
            { x: 1800, y: 560, w: 100, h: 80, type: 'pit' },
            { x: 2150, y: 560, w: 100, h: 80, type: 'pit' },
            { x: 2450, y: 560, w: 100, h: 80, type: 'pit' },
            { x: 2750, y: 560, w: 100, h: 80, type: 'pit' },
            { x: 3100, y: 560, w: 100, h: 80, type: 'pit' },
            { x: 3400, y: 560, w: 100, h: 80, type: 'pit' },
            { x: 3700, y: 560, w: 100, h: 80, type: 'pit' },
            { x: 4050, y: 560, w: 100, h: 80, type: 'pit' },
            { x: 4350, y: 560, w: 100, h: 80, type: 'pit' },
        ],

        decorations: []
    }
};

// ============================================
// CHECKPOINT CLASS
// ============================================
class Checkpoint {
    constructor(data) {
        this.x = data.x;
        this.y = data.y;
        this.id = data.id;
        this.activated = false;
        this.animFrame = 0;
        this.particles = [];
    }

    update() {
        this.animFrame++;
        if (this.activated) {
            // Emit occasional particles when active
            if (Math.random() < 0.05) {
                this.particles.push({
                    x: this.x + Math.random() * 30 - 15,
                    y: this.y - 20,
                    vy: -1 - Math.random(),
                    life: 60,
                    maxLife: 60
                });
            }
        }
        this.particles = this.particles.filter(p => {
            p.y += p.vy;
            p.life--;
            return p.life > 0;
        });
    }

    activate() {
        if (this.activated) return false;
        this.activated = true;
        SaveManager.setCheckpoint(LevelManager.currentLevel, {
            x: this.x,
            y: this.y - 50,
            id: this.id,
            gems: game.gems,
            score: game.score
        });
        game.audio?.playSound('checkpoint');

        // Burst particles
        for (let i = 0; i < 30; i++) {
            this.particles.push({
                x: this.x + Math.random() * 40 - 20,
                y: this.y - 30 + Math.random() * 20,
                vy: -2 - Math.random() * 3,
                life: 60 + Math.random() * 30,
                maxLife: 90
            });
        }

        ToastSystem.show('Checkpoint Activated!');
        return true;
    }

    draw(ctx, cameraX) {
        const screenX = this.x - cameraX;
        if (screenX < -50 || screenX > CONFIG.WIDTH + 50) return;

        ctx.save();
        ctx.translate(screenX, this.y);

        // Flag pole
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(-3, -80, 6, 80);

        // Flag
        const wave = Math.sin(this.animFrame * 0.1) * 5;
        if (this.activated) {
            // Glowing golden flag
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#ffd700';
        } else {
            ctx.fillStyle = '#888';
        }

        ctx.beginPath();
        ctx.moveTo(3, -75);
        ctx.lineTo(40 + wave, -60);
        ctx.lineTo(40 + wave * 0.5, -45);
        ctx.lineTo(3, -55);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;

        // Crystal at base
        if (this.activated) {
            ctx.fillStyle = '#88ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 20;
        } else {
            ctx.fillStyle = '#444';
        }
        ctx.beginPath();
        ctx.moveTo(0, -15);
        ctx.lineTo(12, 0);
        ctx.lineTo(0, 10);
        ctx.lineTo(-12, 0);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;

        // Particles
        this.particles.forEach(p => {
            ctx.globalAlpha = p.life / p.maxLife;
            ctx.fillStyle = this.activated ? '#88ffff' : '#888';
            ctx.beginPath();
            ctx.arc(p.x - this.x, p.y - this.y + this.y, 3, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;

        ctx.restore();
    }

    collidesWith(player) {
        return !this.activated &&
               player.x < this.x + 30 &&
               player.x + player.width > this.x - 30 &&
               player.y < this.y + 10 &&
               player.y + player.height > this.y - 80;
    }
}

// ============================================
// POWERUP CLASS
// ============================================
class PowerUp {
    constructor(data) {
        this.x = data.x;
        this.y = data.y;
        this.type = data.type;
        this.collected = false;
        this.animFrame = Math.random() * 100;
    }

    update() {
        this.animFrame++;
        return !this.collected;
    }

    collect(player) {
        if (this.collected) return;
        this.collected = true;

        game.audio?.playSound('powerup');

        // Apply power-up effect
        const duration = CONFIG.POWERUP_DURATION;
        switch(this.type) {
            case 'doubleJump':
                player.powerups.doubleJump = duration;
                ToastSystem.show('Double Jump!');
                break;
            case 'speedBoost':
                player.powerups.speedBoost = duration;
                ToastSystem.show('Speed Boost!');
                break;
            case 'shield':
                player.powerups.shield = duration;
                player.shieldHits = 1;
                ToastSystem.show('Shield Active!');
                break;
            case 'magnet':
                player.powerups.magnet = duration;
                ToastSystem.show('Coin Magnet!');
                break;
            case 'fury':
                player.powerups.fury = duration;
                ToastSystem.show('Fury Mode!');
                break;
        }

        // Track for achievement
        if (!player.usedPowerups) player.usedPowerups = new Set();
        player.usedPowerups.add(this.type);
        if (player.usedPowerups.size >= 5) {
            AchievementSystem.check('power_collector');
        }

        // Particles
        game.particles.emit(this.x, this.y, 20, {
            colors: this.getColors(),
            speed: 4,
            spread: Math.PI * 2,
            life: 40,
            type: 'star'
        });
    }

    getColors() {
        switch(this.type) {
            case 'doubleJump': return ['#00aaff', '#0066ff', '#ffffff'];
            case 'speedBoost': return ['#ffff00', '#ffaa00', '#ffffff'];
            case 'shield': return ['#00ffff', '#00aaaa', '#ffffff'];
            case 'magnet': return ['#ff00ff', '#aa00aa', '#ffffff'];
            case 'fury': return ['#ff0000', '#ff4400', '#ffff00'];
            default: return ['#ffffff'];
        }
    }

    draw(ctx, cameraX) {
        if (this.collected) return;

        const screenX = this.x - cameraX;
        if (screenX < -50 || screenX > CONFIG.WIDTH + 50) return;

        const hover = Math.sin(this.animFrame * 0.1) * 5;
        const pulse = Math.sin(this.animFrame * 0.15) * 0.2 + 1;

        ctx.save();
        ctx.translate(screenX, this.y + hover);
        ctx.scale(pulse, pulse);

        // Glow
        const colors = this.getColors();
        ctx.shadowColor = colors[0];
        ctx.shadowBlur = 20;

        // Icon based on type
        ctx.fillStyle = colors[0];
        ctx.strokeStyle = colors[1];
        ctx.lineWidth = 2;

        switch(this.type) {
            case 'doubleJump':
                // Double arrow up
                ctx.beginPath();
                ctx.moveTo(0, -15);
                ctx.lineTo(10, -5);
                ctx.lineTo(5, -5);
                ctx.lineTo(5, 5);
                ctx.lineTo(-5, 5);
                ctx.lineTo(-5, -5);
                ctx.lineTo(-10, -5);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(0, -8);
                ctx.lineTo(7, 0);
                ctx.lineTo(-7, 0);
                ctx.closePath();
                ctx.fill();
                break;

            case 'speedBoost':
                // Lightning bolt
                ctx.beginPath();
                ctx.moveTo(5, -15);
                ctx.lineTo(-5, -2);
                ctx.lineTo(2, -2);
                ctx.lineTo(-5, 15);
                ctx.lineTo(8, 0);
                ctx.lineTo(0, 0);
                ctx.closePath();
                ctx.fill();
                break;

            case 'shield':
                // Shield shape
                ctx.beginPath();
                ctx.moveTo(0, -15);
                ctx.lineTo(12, -8);
                ctx.lineTo(12, 2);
                ctx.lineTo(0, 15);
                ctx.lineTo(-12, 2);
                ctx.lineTo(-12, -8);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                break;

            case 'magnet':
                // Magnet shape
                ctx.fillStyle = colors[0];
                ctx.fillRect(-10, -10, 6, 20);
                ctx.fillRect(4, -10, 6, 20);
                ctx.fillRect(-10, -10, 20, 6);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-10, 4, 6, 6);
                ctx.fillStyle = '#0000ff';
                ctx.fillRect(4, 4, 6, 6);
                break;

            case 'fury':
                // Flame/sword
                ctx.beginPath();
                ctx.moveTo(0, -15);
                ctx.lineTo(8, 0);
                ctx.lineTo(3, 0);
                ctx.lineTo(3, 10);
                ctx.lineTo(-3, 10);
                ctx.lineTo(-3, 0);
                ctx.lineTo(-8, 0);
                ctx.closePath();
                ctx.fill();
                // Flames
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(-5, -8, 4, 0, Math.PI * 2);
                ctx.arc(5, -8, 4, 0, Math.PI * 2);
                ctx.fill();
                break;
        }

        ctx.shadowBlur = 0;
        ctx.restore();
    }

    collidesWith(player) {
        if (this.collected) return false;
        return player.x < this.x + 20 &&
               player.x + player.width > this.x - 20 &&
               player.y < this.y + 20 &&
               player.y + player.height > this.y - 20;
    }
}

// ============================================
// BOSS CLASS
// ============================================
class Boss {
    constructor(data) {
        this.x = data.x;
        this.y = data.y;
        this.type = data.type;
        this.baseX = data.x;
        this.baseY = data.y;
        this.width = 80;
        this.height = 100;
        this.health = this.getMaxHealth();
        this.maxHealth = this.health;
        this.phase = 0;
        this.attackTimer = 0;
        this.attackCooldown = 120;
        this.currentAttack = null;
        this.attackFrame = 0;
        this.animFrame = 0;
        this.dead = false;
        this.deathTimer = 0;
        this.invincible = 0;
        this.direction = -1;
        this.activated = false;
        this.projectiles = [];
    }

    getMaxHealth() {
        const healthMap = {
            'boss_spider': 8,
            'boss_golem': 10,
            'boss_serpent': 8,
            'boss_demon': 12,
            'boss_guardian': 10,
            'boss_sorcerer': 15
        };
        return healthMap[this.type] || 10;
    }

    getBossName() {
        const names = {
            'boss_spider': 'Giant Spider',
            'boss_golem': 'Rock Golem',
            'boss_serpent': 'Sea Serpent',
            'boss_demon': 'Fire Demon',
            'boss_guardian': 'Stone Guardian',
            'boss_sorcerer': 'Dark Sorcerer'
        };
        return names[this.type] || 'Boss';
    }

    activate() {
        if (this.activated) return;
        this.activated = true;
        document.getElementById('boss-health-container').style.display = 'flex';
        document.getElementById('boss-name').textContent = this.getBossName();
        game.audio?.playBossMusic();
        ToastSystem.show(`${this.getBossName()} Awakens!`);
    }

    update() {
        if (this.dead) {
            this.deathTimer++;
            return this.deathTimer < 120;
        }

        if (!this.activated) {
            // Check if player is close
            if (game.player && Math.abs(game.player.x - this.x) < 300) {
                this.activate();
            }
            return true;
        }

        this.animFrame++;
        if (this.invincible > 0) this.invincible--;

        // Update health bar
        const healthPercent = (this.health / this.maxHealth) * 100;
        document.getElementById('boss-health-fill').style.width = healthPercent + '%';

        // Phase transitions
        if (this.health <= this.maxHealth * 0.3 && this.phase < 2) {
            this.phase = 2;
            this.attackCooldown = 60; // Faster attacks
        } else if (this.health <= this.maxHealth * 0.6 && this.phase < 1) {
            this.phase = 1;
            this.attackCooldown = 90;
        }

        // Attack logic
        this.attackTimer++;
        if (this.attackTimer >= this.attackCooldown && !this.currentAttack) {
            this.startAttack();
        }

        // Execute current attack
        if (this.currentAttack) {
            this.executeAttack();
        }

        // Face player
        if (game.player) {
            this.direction = game.player.x < this.x ? -1 : 1;
        }

        // Update projectiles
        this.projectiles = this.projectiles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;

            // Check player collision
            if (game.player && !p.hit &&
                game.player.x < p.x + p.size &&
                game.player.x + game.player.width > p.x - p.size &&
                game.player.y < p.y + p.size &&
                game.player.y + game.player.height > p.y - p.size) {
                p.hit = true;
                game.player.takeDamage(p.damage || 20);
            }

            return p.life > 0 && !p.hit;
        });

        return true;
    }

    startAttack() {
        const attacks = this.getAttacks();
        this.currentAttack = attacks[Math.floor(Math.random() * attacks.length)];
        this.attackFrame = 0;
        this.attackTimer = 0;
    }

    getAttacks() {
        switch(this.type) {
            case 'boss_spider':
                return ['webShot', 'jumpAttack', 'summonSpiders'];
            case 'boss_golem':
                return ['groundPound', 'rockThrow', 'charge'];
            case 'boss_serpent':
                return ['waterBlast', 'tailSwipe', 'dive'];
            case 'boss_demon':
                return ['fireball', 'flameWave', 'eruption'];
            case 'boss_guardian':
                return ['spearThrust', 'shieldBash', 'summonSpirits'];
            case 'boss_sorcerer':
                return ['darkBolt', 'shadowOrbs', 'teleport', 'summonMinions'];
            default:
                return ['charge'];
        }
    }

    executeAttack() {
        this.attackFrame++;
        const attackDuration = 90;

        switch(this.currentAttack) {
            case 'webShot':
            case 'darkBolt':
            case 'fireball':
            case 'waterBlast':
            case 'rockThrow':
                // Projectile attacks
                if (this.attackFrame === 30) {
                    const dx = game.player.x - this.x;
                    const dy = game.player.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    this.projectiles.push({
                        x: this.x,
                        y: this.y - 20,
                        vx: (dx / dist) * 8,
                        vy: (dy / dist) * 8,
                        size: 15,
                        life: 120,
                        type: this.currentAttack,
                        damage: 15
                    });
                }
                break;

            case 'jumpAttack':
            case 'charge':
            case 'dive':
                // Movement attacks
                if (this.attackFrame < 30) {
                    // Wind up
                } else if (this.attackFrame < 60) {
                    // Move toward player
                    const speed = 6;
                    this.x += this.direction * speed;
                }
                break;

            case 'groundPound':
            case 'eruption':
            case 'flameWave':
                // AoE attacks
                if (this.attackFrame === 45) {
                    game.screenShake = 20;
                    // Create multiple projectiles
                    for (let i = 0; i < 5; i++) {
                        const angle = (i - 2) * 0.3;
                        this.projectiles.push({
                            x: this.x,
                            y: this.y,
                            vx: Math.cos(angle) * 6,
                            vy: -4,
                            size: 12,
                            life: 90,
                            type: this.currentAttack,
                            damage: 10
                        });
                    }
                }
                break;

            case 'shadowOrbs':
                // Spawn multiple orbs
                if (this.attackFrame === 30 || this.attackFrame === 45 || this.attackFrame === 60) {
                    const angle = Math.random() * Math.PI * 2;
                    this.projectiles.push({
                        x: this.x,
                        y: this.y - 30,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 4,
                        size: 10,
                        life: 150,
                        type: 'shadowOrb',
                        damage: 10
                    });
                }
                break;

            case 'teleport':
                if (this.attackFrame === 30) {
                    // Teleport near player
                    this.x = game.player.x + (Math.random() > 0.5 ? 150 : -150);
                    game.particles.emit(this.x, this.y, 20, {
                        colors: ['#8800ff', '#4400aa', '#ffffff'],
                        speed: 5,
                        spread: Math.PI * 2,
                        life: 30
                    });
                }
                break;
        }

        if (this.attackFrame >= attackDuration) {
            this.currentAttack = null;
        }
    }

    takeDamage(amount = 1) {
        if (this.invincible > 0 || this.dead) return;

        this.health -= amount;
        this.invincible = 30;
        game.audio?.playSound('bossHit');

        game.particles.emit(this.x, this.y - this.height/2, 15, {
            colors: ['#ff0000', '#ff4400', '#ffff00'],
            speed: 5,
            spread: Math.PI * 2,
            life: 30
        });

        if (this.health <= 0) {
            this.die();
        }
    }

    die() {
        this.dead = true;
        game.audio?.playSound('bossDeath');
        document.getElementById('boss-health-container').style.display = 'none';

        // Award points
        game.score += 2000;
        document.getElementById('score').textContent = game.score;

        // Achievement
        AchievementSystem.checkEnemyKill(this.type);

        // Massive particle burst
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                game.particles.emit(
                    this.x + (Math.random() - 0.5) * 50,
                    this.y - 50 + (Math.random() - 0.5) * 50,
                    30,
                    {
                        colors: ['#ff0000', '#ff8800', '#ffff00', '#ffffff'],
                        speed: 8,
                        spread: Math.PI * 2,
                        life: 60,
                        type: 'star'
                    }
                );
                game.screenShake = 15;
            }, i * 200);
        }

        // Trigger level complete after death animation
        setTimeout(() => {
            game.audio?.playLevelMusic(LevelManager.currentLevel);
            GameState.levelComplete();
        }, 2500);
    }

    draw(ctx, cameraX) {
        const screenX = this.x - cameraX;
        if (screenX < -100 || screenX > CONFIG.WIDTH + 100) return;

        ctx.save();
        ctx.translate(screenX, this.y);

        if (this.dead) {
            ctx.globalAlpha = 1 - this.deathTimer / 120;
            ctx.scale(1 + this.deathTimer * 0.01, 1 + this.deathTimer * 0.01);
        }

        if (this.invincible > 0 && Math.floor(this.invincible / 4) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }

        // Draw based on boss type
        this.drawBossSprite(ctx);

        // Draw projectiles
        this.projectiles.forEach(p => {
            ctx.save();
            ctx.translate(p.x - this.x, p.y - this.y);
            ctx.fillStyle = this.getProjectileColor(p.type);
            ctx.shadowColor = ctx.fillStyle;
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(0, 0, p.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });

        ctx.restore();
    }

    getProjectileColor(type) {
        const colors = {
            'webShot': '#aaaaaa',
            'fireball': '#ff4400',
            'waterBlast': '#0088ff',
            'rockThrow': '#886644',
            'darkBolt': '#8800ff',
            'shadowOrb': '#aa00ff',
            'flameWave': '#ff8800',
            'eruption': '#ff2200'
        };
        return colors[type] || '#ffffff';
    }

    drawBossSprite(ctx) {
        const bounce = Math.sin(this.animFrame * 0.1) * 3;

        switch(this.type) {
            case 'boss_spider':
                // Giant spider
                ctx.fillStyle = '#2a1a2a';
                // Body
                ctx.beginPath();
                ctx.ellipse(0, -40 + bounce, 50, 35, 0, 0, Math.PI * 2);
                ctx.fill();
                // Head
                ctx.beginPath();
                ctx.ellipse(this.direction * 30, -50 + bounce, 25, 20, 0, 0, Math.PI * 2);
                ctx.fill();
                // Eyes (8 of them)
                ctx.fillStyle = '#ff0000';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.arc(this.direction * (20 + i * 5), -55 + bounce + (i % 2) * 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Legs
                ctx.strokeStyle = '#1a0a1a';
                ctx.lineWidth = 6;
                for (let i = 0; i < 4; i++) {
                    const legAngle = (i - 1.5) * 0.4 + Math.sin(this.animFrame * 0.1 + i) * 0.1;
                    ctx.beginPath();
                    ctx.moveTo(-30, -30);
                    ctx.lineTo(-30 - Math.cos(legAngle) * 50, -30 + Math.sin(legAngle) * 40);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(30, -30);
                    ctx.lineTo(30 + Math.cos(legAngle) * 50, -30 + Math.sin(legAngle) * 40);
                    ctx.stroke();
                }
                break;

            case 'boss_golem':
                // Rock golem
                ctx.fillStyle = '#5a5a6a';
                // Body
                ctx.fillRect(-35, -90 + bounce, 70, 90);
                // Head
                ctx.fillRect(-25, -120 + bounce, 50, 35);
                // Arms
                ctx.fillRect(-55, -80 + bounce, 25, 60);
                ctx.fillRect(30, -80 + bounce, 25, 60);
                // Eyes
                ctx.fillStyle = '#ffaa00';
                ctx.shadowColor = '#ff8800';
                ctx.shadowBlur = 10;
                ctx.fillRect(-15, -110 + bounce, 10, 8);
                ctx.fillRect(5, -110 + bounce, 10, 8);
                ctx.shadowBlur = 0;
                // Cracks
                ctx.strokeStyle = '#3a3a4a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-10, -90 + bounce);
                ctx.lineTo(5, -50 + bounce);
                ctx.lineTo(-5, -20 + bounce);
                ctx.stroke();
                break;

            case 'boss_serpent':
                // Sea serpent
                ctx.fillStyle = '#2a5a6a';
                // Body segments
                for (let i = 0; i < 5; i++) {
                    const segX = -this.direction * i * 25;
                    const segY = Math.sin(this.animFrame * 0.1 + i * 0.5) * 10;
                    ctx.beginPath();
                    ctx.ellipse(segX, -40 + segY, 25 - i * 3, 20 - i * 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Head
                ctx.fillStyle = '#3a7a8a';
                ctx.beginPath();
                ctx.ellipse(this.direction * 20, -50 + bounce, 30, 25, this.direction * 0.3, 0, Math.PI * 2);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(this.direction * 35, -55 + bounce, 6, 0, Math.PI * 2);
                ctx.fill();
                // Fangs
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.moveTo(this.direction * 40, -40 + bounce);
                ctx.lineTo(this.direction * 45, -25 + bounce);
                ctx.lineTo(this.direction * 35, -40 + bounce);
                ctx.fill();
                break;

            case 'boss_demon':
                // Fire demon
                ctx.fillStyle = '#8a2a1a';
                // Body
                ctx.beginPath();
                ctx.moveTo(0, -100 + bounce);
                ctx.lineTo(40, -30 + bounce);
                ctx.lineTo(30, 0);
                ctx.lineTo(-30, 0);
                ctx.lineTo(-40, -30 + bounce);
                ctx.closePath();
                ctx.fill();
                // Head
                ctx.fillStyle = '#aa3a2a';
                ctx.beginPath();
                ctx.arc(0, -80 + bounce, 25, 0, Math.PI * 2);
                ctx.fill();
                // Horns
                ctx.fillStyle = '#2a1a0a';
                ctx.beginPath();
                ctx.moveTo(-15, -95 + bounce);
                ctx.lineTo(-25, -130 + bounce);
                ctx.lineTo(-10, -100 + bounce);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(15, -95 + bounce);
                ctx.lineTo(25, -130 + bounce);
                ctx.lineTo(10, -100 + bounce);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ff8800';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(-8, -80 + bounce, 5, 0, Math.PI * 2);
                ctx.arc(8, -80 + bounce, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                // Fire aura
                ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
                for (let i = 0; i < 5; i++) {
                    const flameY = Math.sin(this.animFrame * 0.2 + i) * 10;
                    ctx.beginPath();
                    ctx.arc((i - 2) * 15, -50 + flameY, 15, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;

            case 'boss_guardian':
                // Stone guardian with spear and shield
                ctx.fillStyle = '#6a6a7a';
                // Body
                ctx.fillRect(-30, -90 + bounce, 60, 90);
                // Head (helmet)
                ctx.fillStyle = '#5a5a6a';
                ctx.beginPath();
                ctx.moveTo(-25, -90 + bounce);
                ctx.lineTo(0, -130 + bounce);
                ctx.lineTo(25, -90 + bounce);
                ctx.closePath();
                ctx.fill();
                ctx.fillRect(-20, -95 + bounce, 40, 25);
                // Eye slit
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(-15, -85 + bounce, 30, 5);
                // Shield
                ctx.fillStyle = '#4a4a5a';
                ctx.beginPath();
                ctx.moveTo(-50, -70 + bounce);
                ctx.lineTo(-50, -20 + bounce);
                ctx.lineTo(-35, 0);
                ctx.lineTo(-35, -80 + bounce);
                ctx.closePath();
                ctx.fill();
                // Spear
                ctx.fillStyle = '#3a3a4a';
                ctx.fillRect(35, -120 + bounce, 6, 120);
                ctx.fillStyle = '#8a8a9a';
                ctx.beginPath();
                ctx.moveTo(38, -120 + bounce);
                ctx.lineTo(48, -100 + bounce);
                ctx.lineTo(38, -95 + bounce);
                ctx.lineTo(28, -100 + bounce);
                ctx.closePath();
                ctx.fill();
                break;

            case 'boss_sorcerer':
                // Dark sorcerer (final boss)
                // Robe
                ctx.fillStyle = '#1a0a2a';
                ctx.beginPath();
                ctx.moveTo(0, -110 + bounce);
                ctx.lineTo(35, 0);
                ctx.lineTo(-35, 0);
                ctx.closePath();
                ctx.fill();
                // Hood
                ctx.beginPath();
                ctx.arc(0, -90 + bounce, 25, Math.PI, 0);
                ctx.fill();
                // Face (shadowed)
                ctx.fillStyle = '#2a1a3a';
                ctx.beginPath();
                ctx.arc(0, -85 + bounce, 18, 0, Math.PI * 2);
                ctx.fill();
                // Glowing eyes
                ctx.fillStyle = '#ff00ff';
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(-6, -88 + bounce, 4, 0, Math.PI * 2);
                ctx.arc(6, -88 + bounce, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                // Staff
                ctx.fillStyle = '#3a2a1a';
                ctx.fillRect(30, -120 + bounce, 5, 120);
                // Orb on staff
                ctx.fillStyle = '#aa00ff';
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 25;
                ctx.beginPath();
                ctx.arc(32, -130 + bounce, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                // Floating magic particles
                for (let i = 0; i < 5; i++) {
                    const px = Math.sin(this.animFrame * 0.05 + i * 1.2) * 40;
                    const py = Math.cos(this.animFrame * 0.05 + i * 1.2) * 20 - 60;
                    ctx.fillStyle = `rgba(170, 0, 255, ${0.5 + Math.sin(this.animFrame * 0.1 + i) * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(px, py + bounce, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
        }
    }

    collidesWith(player) {
        if (this.dead || !this.activated) return false;
        return player.x < this.x + this.width/2 &&
               player.x + player.width > this.x - this.width/2 &&
               player.y < this.y &&
               player.y + player.height > this.y - this.height;
    }

    collidesWithAttack(box) {
        if (this.dead || !this.activated || !box || this.invincible > 0) return false;
        return box.x < this.x + this.width/2 &&
               box.x + box.w > this.x - this.width/2 &&
               box.y < this.y &&
               box.y + box.h > this.y - this.height;
    }
}

// Audio System (Enhanced)
class AudioSystem {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.musicGain = this.ctx.createGain();
        this.sfxGain = this.ctx.createGain();

        this.masterGain.connect(this.ctx.destination);
        this.musicGain.connect(this.masterGain);
        this.sfxGain.connect(this.masterGain);

        this.masterGain.gain.value = 0.3;
        this.musicGain.gain.value = SaveManager.data.settings.musicVolume / 100;
        this.sfxGain.gain.value = SaveManager.data.settings.sfxVolume / 100;

        this.currentMusic = null;
        this.musicNodes = [];
    }

    setMusicVolume(vol) {
        this.musicGain.gain.value = vol;
    }

    setSfxVolume(vol) {
        this.sfxGain.gain.value = vol;
    }

    playTone(freq, duration, type = 'square', decay = true) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(this.sfxGain);
        gain.gain.value = 0.2;
        if (decay) gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playSound(sound) {
        switch(sound) {
            case 'jump': this.jump(); break;
            case 'attack': this.attack(); break;
            case 'coin': this.coin(); break;
            case 'gem': this.gem(); break;
            case 'hurt': this.hurt(); break;
            case 'enemyHit': this.enemyHit(); break;
            case 'dash': this.dash(); break;
            case 'checkpoint': this.checkpoint(); break;
            case 'powerup': this.powerup(); break;
            case 'achievement': this.achievement(); break;
            case 'victory': this.victory(); break;
            case 'gameOver': this.gameOver(); break;
            case 'bossHit': this.bossHit(); break;
            case 'bossDeath': this.bossDeath(); break;
        }
    }

    jump() {
        this.playTone(200, 0.1, 'square');
        setTimeout(() => this.playTone(300, 0.1, 'square'), 50);
    }

    attack() {
        this.playTone(150, 0.05, 'sawtooth');
        this.playTone(100, 0.1, 'square');
    }

    coin() {
        this.playTone(800, 0.1, 'sine');
        setTimeout(() => this.playTone(1000, 0.15, 'sine'), 80);
    }

    gem() {
        [0, 50, 100, 150].forEach((delay, i) => {
            setTimeout(() => this.playTone(600 + i * 200, 0.1, 'sine'), delay);
        });
    }

    hurt() {
        this.playTone(200, 0.2, 'sawtooth');
        this.playTone(100, 0.3, 'square');
    }

    enemyHit() {
        this.playTone(300, 0.1, 'square');
        this.playTone(150, 0.15, 'sawtooth');
    }

    dash() {
        for (let i = 0; i < 5; i++) {
            setTimeout(() => this.playTone(400 - i * 50, 0.03, 'sawtooth'), i * 20);
        }
    }

    checkpoint() {
        [0, 80, 160, 240].forEach((delay, i) => {
            setTimeout(() => this.playTone(400 + i * 100, 0.15, 'sine'), delay);
        });
    }

    powerup() {
        [0, 50, 100, 150, 200].forEach((delay, i) => {
            setTimeout(() => this.playTone(300 + i * 150, 0.1, 'sine'), delay);
        });
    }

    achievement() {
        const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
        notes.forEach((freq, i) => {
            setTimeout(() => this.playTone(freq, 0.2, 'sine'), i * 100);
        });
    }

    victory() {
        const melody = [523, 587, 659, 784, 659, 784, 1047];
        melody.forEach((freq, i) => {
            setTimeout(() => this.playTone(freq, 0.2, 'sine'), i * 150);
        });
    }

    gameOver() {
        const notes = [400, 350, 300, 250, 200];
        notes.forEach((freq, i) => {
            setTimeout(() => this.playTone(freq, 0.3, 'sawtooth'), i * 200);
        });
    }

    bossHit() {
        this.playTone(150, 0.1, 'sawtooth');
        this.playTone(100, 0.15, 'square');
        this.playTone(80, 0.2, 'sawtooth');
    }

    bossDeath() {
        for (let i = 0; i < 10; i++) {
            setTimeout(() => {
                this.playTone(200 + Math.random() * 300, 0.1, 'sawtooth');
                this.playTone(100 + Math.random() * 200, 0.15, 'square');
            }, i * 100);
        }
        setTimeout(() => this.victory(), 1000);
    }

    stopMusic() {
        this.musicNodes.forEach(node => {
            try { node.stop(); } catch(e) {}
        });
        this.musicNodes = [];
    }

    playLevelMusic(levelNum) {
        this.stopMusic();

        // Theme-based music frequencies
        const themes = {
            1: { base: 220, mood: 'minor' },    // Castle - mysterious
            2: { base: 196, mood: 'minor' },    // Forest - eerie
            3: { base: 262, mood: 'major' },    // Caves - echoing
            4: { base: 175, mood: 'minor' },    // Temple - deep
            5: { base: 294, mood: 'minor' },    // Volcano - intense
            6: { base: 247, mood: 'major' },    // Ruins - ancient
            7: { base: 330, mood: 'major' }     // Sky - ethereal
        };

        const theme = themes[levelNum] || themes[1];
        this.playAmbientMusic(theme.base, theme.mood);
    }

    playAmbientMusic(baseFreq, mood) {
        // Create ambient drone
        const drone = this.ctx.createOscillator();
        const droneGain = this.ctx.createGain();
        drone.type = 'sine';
        drone.frequency.value = baseFreq / 2;
        drone.connect(droneGain);
        droneGain.connect(this.musicGain);
        droneGain.gain.value = 0.05;
        drone.start();
        this.musicNodes.push(drone);

        // Create subtle arpeggios
        const intervals = mood === 'minor' ? [1, 1.2, 1.5, 1.8] : [1, 1.25, 1.5, 2];
        let noteIndex = 0;

        const playNote = () => {
            if (this.musicNodes.length === 0) return;

            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sine';
            osc.frequency.value = baseFreq * intervals[noteIndex % intervals.length];
            osc.connect(gain);
            gain.connect(this.musicGain);
            gain.gain.value = 0.03;
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
            osc.start();
            osc.stop(this.ctx.currentTime + 2);

            noteIndex++;
            setTimeout(playNote, 2000 + Math.random() * 1000);
        };

        setTimeout(playNote, 1000);

        // Ambient noise layer
        const noise = this.ctx.createBufferSource();
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 4, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * 0.01;
        }
        noise.buffer = buffer;
        noise.loop = true;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        noise.connect(filter);
        filter.connect(this.musicGain);
        noise.start();
        this.musicNodes.push(noise);
    }

    playBossMusic() {
        this.stopMusic();

        // Intense boss music
        const baseFreq = 110;
        let beat = 0;

        const playBeat = () => {
            if (this.musicNodes.length === 0) return;

            // Bass drum
            const kick = this.ctx.createOscillator();
            const kickGain = this.ctx.createGain();
            kick.type = 'sine';
            kick.frequency.value = 60;
            kick.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.1);
            kick.connect(kickGain);
            kickGain.connect(this.musicGain);
            kickGain.gain.value = 0.1;
            kickGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
            kick.start();
            kick.stop(this.ctx.currentTime + 0.2);

            // Dramatic chord on certain beats
            if (beat % 4 === 0) {
                [1, 1.2, 1.5].forEach(mult => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sawtooth';
                    osc.frequency.value = baseFreq * mult;
                    osc.connect(gain);
                    gain.connect(this.musicGain);
                    gain.gain.value = 0.03;
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.5);
                });
            }

            beat++;
            setTimeout(playBeat, 400);
        };

        // Store a dummy node to track if music is playing
        const dummyOsc = this.ctx.createOscillator();
        dummyOsc.frequency.value = 0;
        const dummyGain = this.ctx.createGain();
        dummyGain.gain.value = 0;
        dummyOsc.connect(dummyGain);
        dummyGain.connect(this.musicGain);
        dummyOsc.start();
        this.musicNodes.push(dummyOsc);

        playBeat();
    }
}

// Particle System
class Particle {
    constructor(x, y, vx, vy, color, size, life, type = 'circle') {
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.color = color;
        this.size = size;
        this.life = life;
        this.maxLife = life;
        this.type = type;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotSpeed = (Math.random() - 0.5) * 0.2;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.1;
        this.vx *= 0.99;
        this.life--;
        this.rotation += this.rotSpeed;
        return this.life > 0;
    }

    draw(ctx) {
        const alpha = this.life / this.maxLife;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        if (this.type === 'circle') {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.size * alpha, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.type === 'spark') {
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-this.size, 0);
            ctx.lineTo(this.size, 0);
            ctx.stroke();
        } else if (this.type === 'star') {
            ctx.fillStyle = this.color;
            this.drawStar(ctx, 0, 0, 5, this.size * alpha, this.size * alpha * 0.5);
        }
        ctx.restore();
    }

    drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let step = Math.PI / spikes;
        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        for (let i = 0; i < spikes; i++) {
            ctx.lineTo(cx + Math.cos(rot) * outerRadius, cy + Math.sin(rot) * outerRadius);
            rot += step;
            ctx.lineTo(cx + Math.cos(rot) * innerRadius, cy + Math.sin(rot) * innerRadius);
            rot += step;
        }
        ctx.closePath();
        ctx.fill();
    }
}

class ParticleSystem {
    constructor() {
        this.particles = [];
    }

    emit(x, y, count, config) {
        for (let i = 0; i < count; i++) {
            const angle = config.angle || Math.random() * Math.PI * 2;
            const speed = config.speed || (Math.random() * 3 + 1);
            const vx = Math.cos(angle + (Math.random() - 0.5) * (config.spread || 1)) * speed;
            const vy = Math.sin(angle + (Math.random() - 0.5) * (config.spread || 1)) * speed;
            this.particles.push(new Particle(
                x + (Math.random() - 0.5) * 10,
                y + (Math.random() - 0.5) * 10,
                vx, vy,
                config.colors[Math.floor(Math.random() * config.colors.length)],
                config.size || (Math.random() * 4 + 2),
                config.life || (Math.random() * 30 + 20),
                config.type || 'circle'
            ));
        }
    }

    update() {
        this.particles = this.particles.filter(p => p.update());
    }

    draw(ctx) {
        this.particles.forEach(p => p.draw(ctx));
    }
}

// Sprite Rendering System
const Sprites = {
    drawPixelCharacter(ctx, x, y, frame, facingRight, state, isMoving = true, customColors = null) {
        ctx.save();
        ctx.translate(x, y);
        if (!facingRight) {
            ctx.scale(-1, 1);
        }

        const defaultColors = {
            skin: '#e8b89d',
            hair: '#2a1a0a',
            shirt: '#8b0000',
            pants: '#1a1a3a',
            boots: '#3a2a1a',
            cape: '#cc0000',
            gold: '#ffd700',
            blade: '#c0c0c0',
            handle: '#4a3728'
        };
        const colors = customColors ? { ...defaultColors, ...customColors } : defaultColors;

        // Animation offsets - only animate when moving
        const bounce = isMoving ? Math.sin(frame * 0.3) * 2 : 0;
        const armSwing = isMoving ? Math.sin(frame * 0.3) * 15 : 0;
        const legSwing = isMoving ? Math.sin(frame * 0.3) * 20 : 0;

        // Cape (behind character)
        ctx.fillStyle = colors.cape;
        ctx.save();
        ctx.translate(-8, -20);
        ctx.rotate(Math.sin(frame * 0.1) * 0.1 - 0.2);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-15 + Math.sin(frame * 0.15) * 5, 25, -10 + Math.sin(frame * 0.1) * 8, 45);
        ctx.lineTo(5, 40);
        ctx.lineTo(5, 0);
        ctx.fill();
        ctx.restore();

        // Legs
        ctx.save();
        ctx.translate(-5, 10);
        ctx.rotate(legSwing * Math.PI / 180);
        ctx.fillStyle = colors.pants;
        ctx.fillRect(-4, 0, 7, 18);
        ctx.fillStyle = colors.boots;
        ctx.fillRect(-4, 14, 8, 8);
        ctx.restore();

        ctx.save();
        ctx.translate(5, 10);
        ctx.rotate(-legSwing * Math.PI / 180);
        ctx.fillStyle = colors.pants;
        ctx.fillRect(-3, 0, 7, 18);
        ctx.fillStyle = colors.boots;
        ctx.fillRect(-4, 14, 8, 8);
        ctx.restore();

        // Body
        ctx.fillStyle = colors.shirt;
        ctx.fillRect(-10, -20 + bounce, 20, 30);

        // Belt
        ctx.fillStyle = colors.handle;
        ctx.fillRect(-11, 5 + bounce, 22, 5);
        ctx.fillStyle = colors.gold;
        ctx.fillRect(-3, 5 + bounce, 6, 5);

        // Arms
        if (state === 'attack') {
            // Attack pose - sword thrust forward
            ctx.save();
            ctx.translate(10, -10 + bounce);
            ctx.rotate(-0.3);
            ctx.fillStyle = colors.shirt;
            ctx.fillRect(0, -3, 20, 8);
            ctx.fillStyle = colors.skin;
            ctx.fillRect(18, -2, 6, 6);
            // Sword
            ctx.fillStyle = colors.handle;
            ctx.fillRect(22, -1, 8, 4);
            ctx.fillStyle = colors.blade;
            ctx.fillRect(30, -2, 25, 6);
            ctx.fillStyle = '#fff';
            ctx.fillRect(30, -1, 25, 2);
            ctx.restore();
        } else {
            // Normal arm swing
            ctx.save();
            ctx.translate(8, -15 + bounce);
            ctx.rotate(armSwing * Math.PI / 180);
            ctx.fillStyle = colors.shirt;
            ctx.fillRect(0, 0, 8, 18);
            ctx.fillStyle = colors.skin;
            ctx.fillRect(0, 15, 7, 6);
            ctx.restore();

            // Left arm with sword
            ctx.save();
            ctx.translate(-8, -15 + bounce);
            ctx.rotate(-armSwing * Math.PI / 180 - 0.5);
            ctx.fillStyle = colors.shirt;
            ctx.fillRect(-6, 0, 8, 18);
            ctx.fillStyle = colors.skin;
            ctx.fillRect(-6, 15, 7, 6);
            // Sword at rest
            ctx.fillStyle = colors.handle;
            ctx.fillRect(-8, 18, 6, 10);
            ctx.fillStyle = colors.blade;
            ctx.fillRect(-7, 25, 4, 20);
            ctx.restore();
        }

        // Head
        ctx.fillStyle = colors.skin;
        ctx.beginPath();
        ctx.arc(0, -28 + bounce, 12, 0, Math.PI * 2);
        ctx.fill();

        // Hair
        ctx.fillStyle = colors.hair;
        ctx.beginPath();
        ctx.arc(0, -32 + bounce, 11, Math.PI, Math.PI * 2);
        ctx.fill();
        ctx.fillRect(-11, -33 + bounce, 6, 8);

        // Bandana
        ctx.fillStyle = colors.cape;
        ctx.fillRect(-12, -32 + bounce, 24, 5);
        ctx.beginPath();
        ctx.moveTo(-12, -29 + bounce);
        ctx.lineTo(-18 + Math.sin(frame * 0.1) * 2, -25 + bounce);
        ctx.lineTo(-14, -27 + bounce);
        ctx.fill();

        // Face
        ctx.fillStyle = '#000';
        ctx.fillRect(3, -30 + bounce, 3, 3);
        ctx.fillRect(-6, -30 + bounce, 3, 3);
        ctx.fillStyle = '#fff';
        ctx.fillRect(4, -30 + bounce, 1, 1);
        ctx.fillRect(-5, -30 + bounce, 1, 1);

        // Smirk
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(2, -23 + bounce, 4, 0.1, Math.PI - 0.1);
        ctx.stroke();

        ctx.restore();
    },

    drawEnemy(ctx, x, y, frame, type, facingRight) {
        ctx.save();
        ctx.translate(x, y);
        if (!facingRight) ctx.scale(-1, 1);

        const bounce = Math.sin(frame * 0.2) * 2;

        if (type === 'skeleton') {
            const bone = '#e8e8d8';
            const dark = '#2a2a2a';

            // Legs
            ctx.fillStyle = bone;
            ctx.fillRect(-8, 10, 5, 20);
            ctx.fillRect(3, 10, 5, 20);

            // Ribcage
            for (let i = 0; i < 4; i++) {
                ctx.fillRect(-10, -15 + i * 6 + bounce, 20, 3);
            }
            ctx.fillRect(-3, -18 + bounce, 6, 30);

            // Arms
            ctx.save();
            ctx.translate(-10, -10 + bounce);
            ctx.rotate(Math.sin(frame * 0.15) * 0.3);
            ctx.fillRect(-15, 0, 15, 4);
            ctx.fillRect(-18, -2, 5, 8);
            ctx.restore();

            ctx.save();
            ctx.translate(10, -10 + bounce);
            ctx.rotate(-Math.sin(frame * 0.15) * 0.3);
            ctx.fillRect(0, 0, 15, 4);
            // Sword
            ctx.fillStyle = '#666';
            ctx.fillRect(12, -8, 4, 20);
            ctx.restore();

            // Skull
            ctx.fillStyle = bone;
            ctx.beginPath();
            ctx.arc(0, -25 + bounce, 12, 0, Math.PI * 2);
            ctx.fill();

            // Eye sockets
            ctx.fillStyle = dark;
            ctx.beginPath();
            ctx.arc(-4, -27 + bounce, 4, 0, Math.PI * 2);
            ctx.arc(4, -27 + bounce, 4, 0, Math.PI * 2);
            ctx.fill();

            // Red eyes
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(-4, -27 + bounce, 2, 0, Math.PI * 2);
            ctx.arc(4, -27 + bounce, 2, 0, Math.PI * 2);
            ctx.fill();

            // Jaw
            ctx.fillStyle = bone;
            ctx.fillRect(-8, -18 + bounce, 16, 6);
            ctx.fillStyle = dark;
            for (let i = 0; i < 6; i++) {
                ctx.fillRect(-7 + i * 3, -16 + bounce, 1, 4);
            }
        } else if (type === 'ghost') {
            ctx.globalAlpha = 0.7 + Math.sin(frame * 0.1) * 0.2;

            // Body
            const gradient = ctx.createRadialGradient(0, -10, 0, 0, -10, 30);
            gradient.addColorStop(0, '#aaccff');
            gradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(-20, 20);
            for (let i = 0; i < 5; i++) {
                ctx.lineTo(-20 + i * 10, 20 + Math.sin(frame * 0.2 + i) * 5);
            }
            ctx.lineTo(20, -30);
            ctx.arc(0, -30, 20, 0, Math.PI, true);
            ctx.closePath();
            ctx.fill();

            // Face
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-6, -30, 5, 0, Math.PI * 2);
            ctx.arc(6, -30, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(0, -20, 6, 0, Math.PI);
            ctx.fill();
        }

        ctx.restore();
    },

    drawTreasure(ctx, x, y, frame, type) {
        ctx.save();
        ctx.translate(x, y);

        const hover = Math.sin(frame * 0.1) * 3;
        const glow = Math.sin(frame * 0.15) * 0.3 + 0.7;

        ctx.translate(0, hover);

        if (type === 'gem') {
            // Glow effect
            ctx.shadowColor = '#ff00ff';
            ctx.shadowBlur = 15 * glow;

            // Gem shape
            ctx.fillStyle = '#ff00ff';
            ctx.beginPath();
            ctx.moveTo(0, -12);
            ctx.lineTo(10, -4);
            ctx.lineTo(8, 8);
            ctx.lineTo(-8, 8);
            ctx.lineTo(-10, -4);
            ctx.closePath();
            ctx.fill();

            // Shine
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.moveTo(-2, -10);
            ctx.lineTo(4, -6);
            ctx.lineTo(2, 0);
            ctx.lineTo(-4, -4);
            ctx.closePath();
            ctx.fill();
        } else if (type === 'coin') {
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 10 * glow;

            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.ellipse(0, 0, 10, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ffaa00';
            ctx.beginPath();
            ctx.ellipse(0, 0, 7, 7, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 12px serif';
            ctx.textAlign = 'center';
            ctx.fillText('$', 0, 4);
        } else if (type === 'chest') {
            // Chest body
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-18, -8, 36, 20);
            ctx.fillStyle = '#654321';
            ctx.fillRect(-18, -15, 36, 10);

            // Metal bands
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(-20, -8, 4, 20);
            ctx.fillRect(16, -8, 4, 20);
            ctx.fillRect(-20, -10, 40, 4);

            // Lock
            ctx.fillRect(-5, 0, 10, 8);
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(0, 3, 2, 0, Math.PI * 2);
            ctx.fill();

            // Glow from inside
            if (glow > 0.8) {
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 20;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                ctx.fillRect(-15, -12, 30, 5);
            }
        }

        ctx.restore();
    },

    drawHealthPickup(ctx, x, y, frame) {
        ctx.save();
        ctx.translate(x, y);

        const hover = Math.sin(frame * 0.12) * 4;
        const pulse = Math.sin(frame * 0.2) * 0.2 + 1;

        ctx.translate(0, hover);
        ctx.scale(pulse, pulse);

        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 15;

        // Heart shape
        ctx.fillStyle = '#ff3333';
        ctx.beginPath();
        ctx.moveTo(0, 5);
        ctx.bezierCurveTo(-10, -5, -15, -15, 0, -8);
        ctx.bezierCurveTo(15, -15, 10, -5, 0, 5);
        ctx.fill();

        // Shine
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath();
        ctx.ellipse(-4, -8, 3, 2, -0.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }
};

// Level Design
const LEVEL = {
    width: 3200,
    height: CONFIG.HEIGHT,
    platforms: [
        // Ground level
        { x: 0, y: 560, w: 400, h: 80, type: 'ground' },
        { x: 450, y: 560, w: 200, h: 80, type: 'ground' },
        { x: 700, y: 560, w: 300, h: 80, type: 'ground' },
        { x: 1050, y: 560, w: 150, h: 80, type: 'ground' },
        { x: 1250, y: 560, w: 500, h: 80, type: 'ground' },
        { x: 1800, y: 560, w: 200, h: 80, type: 'ground' },
        { x: 2050, y: 560, w: 300, h: 80, type: 'ground' },
        { x: 2400, y: 560, w: 400, h: 80, type: 'ground' },
        { x: 2850, y: 560, w: 350, h: 80, type: 'ground' },

        // Floating platforms
        { x: 150, y: 450, w: 120, h: 25, type: 'stone' },
        { x: 350, y: 380, w: 100, h: 25, type: 'stone' },
        { x: 550, y: 450, w: 100, h: 25, type: 'wood' },
        { x: 720, y: 350, w: 150, h: 25, type: 'stone' },
        { x: 950, y: 420, w: 80, h: 25, type: 'wood' },
        { x: 1100, y: 350, w: 100, h: 25, type: 'stone' },
        { x: 1300, y: 450, w: 120, h: 25, type: 'wood' },
        { x: 1450, y: 380, w: 100, h: 25, type: 'stone' },
        { x: 1600, y: 300, w: 150, h: 25, type: 'stone' },
        { x: 1850, y: 400, w: 100, h: 25, type: 'wood' },
        { x: 2000, y: 320, w: 120, h: 25, type: 'stone' },
        { x: 2200, y: 400, w: 100, h: 25, type: 'wood' },
        { x: 2400, y: 350, w: 150, h: 25, type: 'stone' },
        { x: 2650, y: 420, w: 100, h: 25, type: 'wood' },
        { x: 2850, y: 350, w: 120, h: 25, type: 'stone' },
        { x: 3000, y: 280, w: 150, h: 25, type: 'stone' },

        // High platforms
        { x: 200, y: 280, w: 80, h: 20, type: 'wood' },
        { x: 800, y: 220, w: 100, h: 20, type: 'stone' },
        { x: 1200, y: 250, w: 80, h: 20, type: 'wood' },
        { x: 1700, y: 200, w: 120, h: 20, type: 'stone' },
        { x: 2100, y: 220, w: 100, h: 20, type: 'wood' },
        { x: 2500, y: 200, w: 120, h: 20, type: 'stone' },
    ],
    treasures: [],
    enemies: [],
    decorations: []
};

// Initialize level content
function initLevel() {
    LEVEL.treasures = [
        // Coins scattered around
        { x: 180, y: 420, type: 'coin' },
        { x: 220, y: 420, type: 'coin' },
        { x: 380, y: 350, type: 'coin' },
        { x: 580, y: 420, type: 'coin' },
        { x: 750, y: 320, type: 'gem' },
        { x: 980, y: 390, type: 'coin' },
        { x: 1130, y: 320, type: 'coin' },
        { x: 1330, y: 420, type: 'coin' },
        { x: 1480, y: 350, type: 'gem' },
        { x: 1650, y: 270, type: 'coin' },
        { x: 1880, y: 370, type: 'coin' },
        { x: 2030, y: 290, type: 'gem' },
        { x: 2230, y: 370, type: 'coin' },
        { x: 2450, y: 320, type: 'coin' },
        { x: 2680, y: 390, type: 'coin' },
        { x: 2900, y: 320, type: 'gem' },
        { x: 3050, y: 250, type: 'chest' },

        // Health pickups
        { x: 600, y: 530, type: 'health' },
        { x: 1400, y: 530, type: 'health' },
        { x: 2300, y: 530, type: 'health' },

        // Secret area coins
        { x: 230, y: 250, type: 'gem' },
        { x: 830, y: 190, type: 'gem' },
        { x: 1730, y: 170, type: 'gem' },
    ];

    LEVEL.enemies = [
        { x: 500, y: 500, type: 'skeleton', patrolStart: 450, patrolEnd: 650 },
        { x: 900, y: 500, type: 'skeleton', patrolStart: 850, patrolEnd: 1000 },
        { x: 1350, y: 500, type: 'skeleton', patrolStart: 1280, patrolEnd: 1500 },
        { x: 1950, y: 500, type: 'skeleton', patrolStart: 1850, patrolEnd: 2050 },
        { x: 2550, y: 500, type: 'skeleton', patrolStart: 2450, patrolEnd: 2700 },
        { x: 2950, y: 500, type: 'skeleton', patrolStart: 2880, patrolEnd: 3100 },

        // Ghosts on platforms
        { x: 780, y: 290, type: 'ghost', patrolStart: 720, patrolEnd: 870 },
        { x: 1650, y: 240, type: 'ghost', patrolStart: 1600, patrolEnd: 1750 },
        { x: 2450, y: 290, type: 'ghost', patrolStart: 2400, patrolEnd: 2550 },
    ];

    // Generate decorations
    LEVEL.decorations = [];
    for (let x = 0; x < LEVEL.width; x += 150 + Math.random() * 200) {
        if (Math.random() > 0.3) {
            LEVEL.decorations.push({
                x: x,
                y: 560,
                type: Math.random() > 0.5 ? 'torch' : 'pillar'
            });
        }
    }
}

// Background Layers for Parallax (Theme-Based)
class Background {
    constructor(theme = 'castle') {
        this.theme = theme;
        this.layers = [];
        this.createLayers();
    }

    createLayers() {
        this.layers = [
            { speed: 0, draw: this.drawSky.bind(this) },
            { speed: 0.1, draw: this.drawDistant.bind(this) },
            { speed: 0.2, draw: this.drawMiddle.bind(this) },
            { speed: 0.4, draw: this.drawNear.bind(this) },
            { speed: 0.6, draw: this.drawFog.bind(this) }
        ];
    }

    getThemeColors() {
        const themes = {
            castle: { sky: ['#0a0a1a', '#1a1a3a', '#2a1a2a', '#1a0a1a'], mountain: '#151525', fog: 'rgba(100, 100, 150, 0.5)', accent: '#ffaa00' },
            forest: { sky: ['#0a1a0a', '#1a2a1a', '#0a1a0a', '#051005'], mountain: '#0a150a', fog: 'rgba(50, 100, 50, 0.4)', accent: '#88ff88' },
            caves: { sky: ['#0a0a15', '#15152a', '#0a0a20', '#05050a'], mountain: '#101020', fog: 'rgba(100, 100, 200, 0.3)', accent: '#88ffff' },
            temple: { sky: ['#0a1520', '#152535', '#1a3040', '#0a1520'], mountain: '#0a2030', fog: 'rgba(50, 100, 150, 0.4)', accent: '#00aaff' },
            volcano: { sky: ['#1a0a0a', '#2a1510', '#3a1a0a', '#1a0505'], mountain: '#1a0a05', fog: 'rgba(150, 50, 30, 0.4)', accent: '#ff4400' },
            ruins: { sky: ['#15150a', '#252515', '#201a0a', '#100a05'], mountain: '#1a1a0a', fog: 'rgba(150, 140, 100, 0.3)', accent: '#ddcc88' },
            sky: { sky: ['#1a3050', '#3050a0', '#5080d0', '#80b0ff'], mountain: '#4060a0', fog: 'rgba(200, 220, 255, 0.4)', accent: '#ffffff' }
        };
        return themes[this.theme] || themes.castle;
    }

    drawSky(ctx, offset, frame) {
        const colors = this.getThemeColors();
        const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.HEIGHT);
        colors.sky.forEach((color, i) => gradient.addColorStop(i / (colors.sky.length - 1), color));
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

        if (this.theme !== 'sky') {
            // Stars
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 100; i++) {
                const x = (i * 137 + Math.sin(frame * 0.01 + i) * 2) % CONFIG.WIDTH;
                const y = (i * 73) % (CONFIG.HEIGHT * 0.6);
                ctx.globalAlpha = 0.3 + Math.sin(frame * 0.02 + i * 0.5) * 0.3;
                ctx.fillRect(x, y, (Math.sin(frame * 0.05 + i) + 1) * 1.5, (Math.sin(frame * 0.05 + i) + 1) * 1.5);
            }
            ctx.globalAlpha = 1;
            // Moon
            if (['castle', 'forest', 'caves'].includes(this.theme)) {
                ctx.fillStyle = '#ffffee';
                ctx.shadowColor = '#ffffaa';
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(CONFIG.WIDTH - 100, 80, 40, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        } else {
            // Sun
            ctx.fillStyle = '#ffff88';
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 50;
            ctx.beginPath();
            ctx.arc(150, 100, 50, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            // Clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 8; i++) {
                const cx = ((i * 200 - offset * 0.3 + frame * 0.2) % (CONFIG.WIDTH + 300)) - 100;
                ctx.beginPath();
                ctx.arc(cx, 80 + (i * 47) % 150, 30 + (i % 3) * 15, 0, Math.PI * 2);
                ctx.arc(cx + 25, 75 + (i * 47) % 150, 20, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        // Theme particles
        if (this.theme === 'volcano') {
            ctx.fillStyle = '#ff4400';
            for (let i = 0; i < 30; i++) {
                ctx.globalAlpha = 0.3 + Math.sin(frame * 0.1 + i) * 0.2;
                ctx.beginPath();
                ctx.arc((i * 107 + frame * (1 + i % 3)) % CONFIG.WIDTH, (i * 83 + frame * 0.5) % CONFIG.HEIGHT, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
    }

    drawDistant(ctx, offset, frame) {
        const colors = this.getThemeColors();
        ctx.fillStyle = colors.mountain;
        if (this.theme === 'sky') {
            for (let i = 0; i < 5; i++) {
                const ix = (i * 300 - offset) % (CONFIG.WIDTH + 400) - 100;
                ctx.fillStyle = '#4a6090';
                ctx.beginPath();
                ctx.ellipse(ix, 300 + Math.sin(frame * 0.02 + i) * 20, 80, 25, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        } else {
            ctx.beginPath();
            ctx.moveTo(0, CONFIG.HEIGHT);
            for (let x = 0; x <= CONFIG.WIDTH + 100; x += 100) {
                ctx.lineTo(x, CONFIG.HEIGHT - (250 + Math.sin((x + offset) * 0.005) * 100 + Math.sin((x + offset) * 0.002) * 50));
            }
            ctx.lineTo(CONFIG.WIDTH, CONFIG.HEIGHT);
            ctx.fill();
        }
    }

    drawMiddle(ctx, offset, frame) {
        const colors = this.getThemeColors();
        if (this.theme === 'castle') {
            const castleX = 400 - offset * 0.5;
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(castleX, 200, 200, 300);
            ctx.fillRect(castleX - 30, 180, 50, 320);
            ctx.fillRect(castleX + 180, 180, 50, 320);
            ctx.beginPath();
            ctx.moveTo(castleX - 40, 180);
            ctx.lineTo(castleX - 5, 100);
            ctx.lineTo(castleX + 30, 180);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(castleX + 170, 180);
            ctx.lineTo(castleX + 205, 100);
            ctx.lineTo(castleX + 240, 180);
            ctx.fill();
            ctx.fillStyle = colors.accent;
            ctx.shadowColor = colors.accent;
            ctx.shadowBlur = 10;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 4; j++) {
                    if (Math.sin(frame * 0.02 + i + j) > 0) ctx.fillRect(castleX + 60 + i * 40, 220 + j * 50, 15, 25);
                }
            }
            ctx.shadowBlur = 0;
        } else if (this.theme === 'forest') {
            for (let i = 0; i < 10; i++) {
                const x = (i * 220 - offset) % (CONFIG.WIDTH + 200) - 100;
                ctx.fillStyle = '#0a150a';
                ctx.fillRect(x - 8, CONFIG.HEIGHT - 200, 16, 200);
                ctx.fillStyle = '#051008';
                for (let j = 0; j < 5; j++) {
                    ctx.beginPath();
                    ctx.moveTo(x, CONFIG.HEIGHT - 180 + j * 25);
                    ctx.lineTo(x - 50 + j * 10, CONFIG.HEIGHT - 160 + j * 25);
                    ctx.lineTo(x + 50 - j * 10, CONFIG.HEIGHT - 160 + j * 25);
                    ctx.fill();
                }
            }
        } else if (this.theme === 'caves') {
            for (let i = 0; i < 12; i++) {
                const x = (i * 180 - offset) % (CONFIG.WIDTH + 200) - 50;
                const hue = (i * 40) % 360;
                ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.6)`;
                ctx.shadowColor = `hsla(${hue}, 70%, 60%, 0.8)`;
                ctx.shadowBlur = 20 + Math.sin(frame * 0.1 + i) * 10;
                ctx.beginPath();
                ctx.moveTo(x, CONFIG.HEIGHT - 80);
                ctx.lineTo(x + 15, CONFIG.HEIGHT - 160);
                ctx.lineTo(x - 15, CONFIG.HEIGHT - 160);
                ctx.closePath();
                ctx.fill();
            }
            ctx.shadowBlur = 0;
        } else if (this.theme === 'volcano') {
            const vx = 500 - offset * 0.3;
            ctx.fillStyle = '#2a1a0a';
            ctx.beginPath();
            ctx.moveTo(vx - 200, CONFIG.HEIGHT);
            ctx.lineTo(vx - 50, 150);
            ctx.lineTo(vx + 50, 150);
            ctx.lineTo(vx + 200, CONFIG.HEIGHT);
            ctx.fill();
            ctx.fillStyle = `rgba(255, ${100 + Math.sin(frame * 0.1) * 50}, 0, 0.8)`;
            ctx.shadowColor = '#ff4400';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.ellipse(vx, 160, 40, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    drawNear(ctx, offset, frame) {
        if (this.theme === 'forest') {
            for (let i = 0; i < 15; i++) {
                const x = (i * 180 - offset * 1.5) % (CONFIG.WIDTH + 200) - 100;
                ctx.fillStyle = '#1a2a1a';
                ctx.fillRect(x - 6, CONFIG.HEIGHT - 150, 12, 150);
                ctx.fillStyle = '#0a1510';
                for (let j = 0; j < 4; j++) {
                    ctx.beginPath();
                    ctx.moveTo(x, CONFIG.HEIGHT - 130 + j * 25);
                    ctx.lineTo(x - 40 + j * 8, CONFIG.HEIGHT - 115 + j * 25);
                    ctx.lineTo(x + 40 - j * 8, CONFIG.HEIGHT - 115 + j * 25);
                    ctx.fill();
                }
            }
        }
    }

    drawFog(ctx, offset, frame) {
        const colors = this.getThemeColors();
        ctx.globalAlpha = 0.15;
        for (let i = 0; i < 5; i++) {
            const x = ((i * 300 - offset + frame * 0.5) % (CONFIG.WIDTH + 400)) - 200;
            const gradient = ctx.createRadialGradient(x, 400 + Math.sin(frame * 0.01 + i) * 30, 0, x, 400, 150);
            gradient.addColorStop(0, colors.fog);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fillRect(x - 150, 300, 300, 200);
        }
        ctx.globalAlpha = 1;
    }

    draw(ctx, cameraX, frame) {
        this.layers.forEach(layer => layer.draw(ctx, cameraX * layer.speed, frame));
    }
}

// Platform Rendering
function drawPlatform(ctx, platform, cameraX) {
    const x = platform.x - cameraX;
    const y = platform.y;

    if (x + platform.w < -50 || x > CONFIG.WIDTH + 50) return;

    ctx.save();

    if (platform.type === 'ground') {
        // Ground with grass
        ctx.fillStyle = '#3a2a1a';
        ctx.fillRect(x, y, platform.w, platform.h);

        // Grass on top
        ctx.fillStyle = '#2a4a2a';
        ctx.fillRect(x, y, platform.w, 8);

        // Grass blades
        ctx.fillStyle = '#3a6a3a';
        for (let i = 0; i < platform.w; i += 6) {
            const height = 5 + Math.sin(i * 0.3) * 3;
            ctx.fillRect(x + i, y - height, 3, height + 2);
        }

        // Dirt texture
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        for (let i = 0; i < 10; i++) {
            const px = x + (i * 47) % platform.w;
            const py = y + 15 + (i * 23) % 40;
            ctx.beginPath();
            ctx.arc(px, py, 3 + i % 3, 0, Math.PI * 2);
            ctx.fill();
        }
    } else if (platform.type === 'stone') {
        // Stone platform
        ctx.fillStyle = '#4a4a5a';
        ctx.fillRect(x, y, platform.w, platform.h);

        // Stone texture
        ctx.fillStyle = '#3a3a4a';
        ctx.fillRect(x + 2, y + 2, platform.w - 4, platform.h - 4);

        // Cracks
        ctx.strokeStyle = '#2a2a3a';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + platform.w * 0.3, y);
        ctx.lineTo(x + platform.w * 0.35, y + platform.h);
        ctx.moveTo(x + platform.w * 0.7, y);
        ctx.lineTo(x + platform.w * 0.65, y + platform.h);
        ctx.stroke();

        // Highlight
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(x, y, platform.w, 3);
    } else if (platform.type === 'wood') {
        // Wooden platform
        ctx.fillStyle = '#5a4030';
        ctx.fillRect(x, y, platform.w, platform.h);

        // Wood grain
        ctx.strokeStyle = '#4a3020';
        ctx.lineWidth = 2;
        for (let i = 0; i < platform.h; i += 6) {
            ctx.beginPath();
            ctx.moveTo(x, y + i);
            ctx.lineTo(x + platform.w, y + i + Math.sin(i) * 2);
            ctx.stroke();
        }

        // Nails
        ctx.fillStyle = '#888';
        ctx.fillRect(x + 5, y + 5, 4, 4);
        ctx.fillRect(x + platform.w - 9, y + 5, 4, 4);
    } else if (platform.type === 'cloud' || platform.type === 'cloudTemp') {
        // Cloud platform
        ctx.fillStyle = platform.type === 'cloudTemp' ?
            `rgba(255, 255, 255, ${platform.alpha || 0.8})` :
            'rgba(240, 245, 255, 0.9)';

        // Puffy cloud shape
        const midX = x + platform.w / 2;
        ctx.beginPath();
        ctx.arc(midX, y + 10, platform.w * 0.3, 0, Math.PI * 2);
        ctx.arc(midX - platform.w * 0.25, y + 15, platform.w * 0.2, 0, Math.PI * 2);
        ctx.arc(midX + platform.w * 0.25, y + 15, platform.w * 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.arc(midX - 10, y + 5, 10, 0, Math.PI * 2);
        ctx.fill();
    } else if (platform.type === 'crystal') {
        // Crystal platform (crumbling type)
        const alpha = platform.crumbleTime ? Math.max(0, 1 - platform.crumbleTime / 90) : 1;
        const hue = (platform.x * 0.5) % 360;

        ctx.fillStyle = `hsla(${hue}, 70%, 60%, ${alpha * 0.8})`;
        ctx.shadowColor = `hsla(${hue}, 70%, 70%, ${alpha})`;
        ctx.shadowBlur = 15;

        // Crystal shape
        ctx.beginPath();
        ctx.moveTo(x, y + platform.h);
        ctx.lineTo(x + platform.w * 0.2, y);
        ctx.lineTo(x + platform.w * 0.5, y - 5);
        ctx.lineTo(x + platform.w * 0.8, y);
        ctx.lineTo(x + platform.w, y + platform.h);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;

        // Shimmer
        ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.sin(game.frame * 0.1 + platform.x) * 0.2})`;
        ctx.fillRect(x + platform.w * 0.3, y + 2, platform.w * 0.2, platform.h * 0.5);
    }

    ctx.restore();
}

// Decoration Rendering
function drawDecoration(ctx, deco, cameraX, frame) {
    const x = deco.x - cameraX;
    if (x < -100 || x > CONFIG.WIDTH + 100) return;

    ctx.save();
    ctx.translate(x, deco.y);

    if (deco.type === 'torch') {
        // Torch holder
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(-5, -40, 10, 40);

        // Flame
        const flicker = Math.sin(frame * 0.3) * 3;
        const gradient = ctx.createRadialGradient(0, -50, 0, 0, -45, 20 + flicker);
        gradient.addColorStop(0, '#ffff00');
        gradient.addColorStop(0.3, '#ff8800');
        gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, -50, 20 + flicker, 0, Math.PI * 2);
        ctx.fill();

        // Light glow on ground
        ctx.globalAlpha = 0.3;
        const groundGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 60);
        groundGlow.addColorStop(0, '#ff8800');
        groundGlow.addColorStop(1, 'transparent');
        ctx.fillStyle = groundGlow;
        ctx.fillRect(-60, -20, 120, 40);
    } else if (deco.type === 'pillar') {
        // Stone pillar
        ctx.fillStyle = '#3a3a4a';
        ctx.fillRect(-15, -80, 30, 80);

        // Top decoration
        ctx.fillRect(-20, -90, 40, 15);

        // Cracks
        ctx.strokeStyle = '#2a2a3a';
        ctx.beginPath();
        ctx.moveTo(-5, -60);
        ctx.lineTo(5, -30);
        ctx.lineTo(-3, -10);
        ctx.stroke();
    }

    ctx.restore();
}

// Game State
const game = {
    started: false,
    frame: 0,
    cameraX: 0,
    screenShake: 0,
    player: null,
    enemies: [],
    treasures: [],
    checkpoints: [],
    powerups: [],
    hazards: [],
    platforms: [],
    decorations: [],
    gems: 0,
    score: 0,
    health: 100,
    audio: null,
    audioInitialized: false,
    particles: null,
    background: null,
    levelWidth: 3200,
    levelHeight: 640
};

// Player Class (Enhanced with power-ups and character stats)
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.width = 30;
        this.height = 50;
        this.grounded = false;
        this.facingRight = true;
        this.state = 'idle';
        this.attackCooldown = 0;
        this.attackDuration = 0;
        this.dashCooldown = 0;
        this.dashing = false;
        this.dashTime = 0;
        this.invincible = 0;
        this.animFrame = 0;
        this.coyoteTime = 0;
        this.jumpBuffered = false;
        this.jumpKeyHeld = false;

        // Power-up system
        this.powerups = {
            doubleJump: 0,
            speedBoost: 0,
            shield: 0,
            magnet: 0,
            fury: 0
        };
        this.canDoubleJump = false;
        this.hasDoubleJumped = false;
        this.shieldHits = 0;
        this.damageTaken = 0;
        this.attackCount = 0;
        this.usedPowerups = new Set();

        // Character stats
        this.character = Characters.getCurrent();
        this.colors = this.character.colors;
    }

    update(keys, platforms) {
        this.animFrame++;

        // Update power-up timers
        for (const key in this.powerups) {
            if (this.powerups[key] > 0) {
                this.powerups[key]--;
                if (this.powerups[key] === 0 && key === 'doubleJump') {
                    this.canDoubleJump = false;
                }
            }
        }

        // Update power-up display
        this.updatePowerupDisplay();

        // Decrease cooldowns
        if (this.attackCooldown > 0) this.attackCooldown--;
        if (this.dashCooldown > 0) this.dashCooldown--;
        if (this.invincible > 0) this.invincible--;
        if (this.attackDuration > 0) this.attackDuration--;

        // Coyote time for jumps
        if (this.grounded) {
            this.coyoteTime = 8;
            this.hasDoubleJumped = false;
        } else if (this.coyoteTime > 0) {
            this.coyoteTime--;
        }

        // Handle dashing
        if (this.dashing) {
            this.dashTime--;
            if (this.dashTime <= 0) {
                this.dashing = false;
            }
            const dashSpeed = 8 * this.character.stats.speed;
            this.vx = this.facingRight ? dashSpeed : -dashSpeed;
            this.vy = 0;
        } else {
            // Horizontal movement with character speed modifier
            const baseSpeed = 2.5 * this.character.stats.speed;
            const speedBoost = this.powerups.speedBoost > 0 ? 1.5 : 1;
            const speed = baseSpeed * speedBoost;

            if (keys.left) {
                this.vx -= 0.35 * speedBoost;
                this.facingRight = false;
            }
            if (keys.right) {
                this.vx += 0.35 * speedBoost;
                this.facingRight = true;
            }

            this.vx = Math.max(-speed, Math.min(speed, this.vx));
            this.vx *= 0.92;

            // Gravity
            this.vy += CONFIG.GRAVITY;
            this.vy = Math.min(10, this.vy);
        }

        // Jump handling
        const jumpHeight = -10 * this.character.stats.jumpHeight;

        if (keys.jump && !this.jumpKeyHeld) {
            this.jumpKeyHeld = true;
            if (this.coyoteTime > 0) {
                this.vy = jumpHeight;
                this.grounded = false;
                this.coyoteTime = 0;
                game.audio?.jump();
                this.emitJumpParticles();
            } else if (this.powerups.doubleJump > 0 && !this.hasDoubleJumped) {
                // Double jump
                this.vy = jumpHeight * 0.9;
                this.hasDoubleJumped = true;
                game.audio?.jump();
                this.emitJumpParticles();
                game.particles.emit(this.x + this.width/2, this.y + this.height, 15, {
                    colors: ['#00aaff', '#0066ff', '#ffffff'],
                    angle: -Math.PI/2,
                    spread: 1,
                    speed: 4,
                    life: 25
                });
            } else {
                this.jumpBuffered = true;
            }
        }
        if (!keys.jump) {
            this.jumpKeyHeld = false;
        }

        // Buffer jump
        if (this.jumpBuffered && this.grounded && !this.jumpKeyHeld) {
            this.vy = jumpHeight;
            this.grounded = false;
            this.jumpBuffered = false;
            game.audio?.jump();
            this.emitJumpParticles();
        }

        // Dash
        if (keys.dash && this.dashCooldown === 0 && !this.dashing) {
            this.dashing = true;
            this.dashTime = 10;
            this.dashCooldown = 45;
            game.audio?.dash();
            this.emitDashParticles();
            AchievementSystem.check('dash_master');
        }

        // Attack
        if (keys.attack && this.attackCooldown === 0) {
            this.state = 'attack';
            this.attackCooldown = 25;
            this.attackDuration = 15;
            this.attackCount++;
            game.audio?.attack();
            this.emitAttackParticles();
        }

        if (this.attackDuration === 0 && this.state === 'attack') {
            this.state = 'idle';
        }

        // Apply velocity
        this.x += this.vx;
        this.y += this.vy;

        // Magnet effect - attract nearby coins
        if (this.powerups.magnet > 0) {
            game.treasures?.forEach(t => {
                if (!t.collected && (t.type === 'coin' || t.type === 'gem')) {
                    const dx = this.x - t.x;
                    const dy = this.y - t.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 150 && dist > 5) {
                        t.x += dx / dist * 4;
                        t.y += dy / dist * 4;
                    }
                }
            });
        }

        // Platform collision
        this.grounded = false;
        const levelWidth = game.levelWidth || 3200;
        platforms.forEach(p => {
            if (this.x + this.width > p.x && this.x < p.x + p.w) {
                // Landing on top of platform
                if (this.y + this.height > p.y && this.y + this.height < p.y + 20 && this.vy >= 0) {
                    this.y = p.y - this.height;
                    this.vy = 0;
                    this.grounded = true;

                    if (this.jumpBuffered && !this.jumpKeyHeld) {
                        this.vy = jumpHeight;
                        this.grounded = false;
                        this.jumpBuffered = false;
                        game.audio?.jump();
                        this.emitJumpParticles();
                    }
                }
                // Hitting platform from below (head collision)
                else if (this.y < p.y + p.h && this.y > p.y && this.vy < 0) {
                    this.y = p.y + p.h;
                    this.vy = 0;
                }
            }
        });

        // World bounds
        this.x = Math.max(0, Math.min(levelWidth - this.width, this.x));

        // Fall death
        if (this.y > CONFIG.HEIGHT + 100) {
            this.respawnAtCheckpoint();
        }

        // Speed boost particles
        if (this.powerups.speedBoost > 0 && Math.abs(this.vx) > 1) {
            game.particles?.emit(this.x + this.width/2, this.y + this.height/2, 1, {
                colors: ['#ffff00', '#ffaa00'],
                angle: this.facingRight ? Math.PI : 0,
                spread: 0.2,
                speed: 2,
                life: 10
            });
        }

        // Fury effect particles
        if (this.powerups.fury > 0) {
            game.particles?.emit(this.x + this.width/2, this.y + this.height - 5, 1, {
                colors: ['#ff0000', '#ff4400', '#ffff00'],
                angle: -Math.PI/2,
                spread: 0.5,
                speed: 2,
                life: 15
            });
        }
    }

    updatePowerupDisplay() {
        const display = document.getElementById('powerup-display');
        if (!display) return;

        display.innerHTML = '';
        const powerupInfo = {
            doubleJump: { name: 'Double Jump', color: '#00aaff' },
            speedBoost: { name: 'Speed', color: '#ffff00' },
            shield: { name: 'Shield', color: '#00ffff' },
            magnet: { name: 'Magnet', color: '#ff00ff' },
            fury: { name: 'Fury', color: '#ff0000' }
        };

        for (const [key, time] of Object.entries(this.powerups)) {
            if (time > 0) {
                const info = powerupInfo[key];
                const percent = (time / CONFIG.POWERUP_DURATION) * 100;
                display.innerHTML += `
                    <div class="powerup-timer">
                        <span style="color:${info.color}">${info.name}</span>
                        <div class="powerup-bar">
                            <div class="powerup-bar-fill" style="width:${percent}%;background:${info.color}"></div>
                        </div>
                    </div>
                `;
            }
        }
    }

    respawnAtCheckpoint() {
        const checkpoint = SaveManager.getCheckpoint(LevelManager.currentLevel);
        if (checkpoint) {
            this.x = checkpoint.x;
            this.y = checkpoint.y;
        } else {
            const lvl = LevelManager.currentLevelData;
            this.x = lvl?.playerStart?.x || 100;
            this.y = lvl?.playerStart?.y || 400;
        }
        this.vx = 0;
        this.vy = 0;
        this.takeDamage(20);
        GameState.playerDied();
    }

    takeDamage(amount) {
        if (this.invincible > 0) return;

        // Shield absorbs hit
        if (this.powerups.shield > 0 && this.shieldHits > 0) {
            this.shieldHits--;
            if (this.shieldHits <= 0) {
                this.powerups.shield = 0;
            }
            this.invincible = 30;
            game.particles?.emit(this.x + this.width/2, this.y + this.height/2, 20, {
                colors: ['#00ffff', '#00aaaa', '#ffffff'],
                speed: 5,
                spread: Math.PI * 2,
                life: 30
            });
            game.audio?.playSound('hurt');
            return;
        }

        this.damageTaken += amount;
        game.health -= amount;
        this.invincible = 60;
        if (SaveManager.data.settings.screenShake) {
            game.screenShake = 10;
        }
        game.audio?.hurt();

        // Blood particles
        game.particles?.emit(this.x + this.width/2, this.y + this.height/2, 15, {
            colors: ['#ff0000', '#aa0000', '#ff3333'],
            speed: 5,
            spread: Math.PI * 2,
            life: 40
        });

        if (game.health <= 0) {
            GameState.gameOver();
        }

        document.getElementById('health').textContent = Math.max(0, game.health);
    }

    emitJumpParticles() {
        game.particles?.emit(this.x + this.width/2, this.y + this.height, 10, {
            colors: ['#888', '#666', '#aaa'],
            angle: -Math.PI/2,
            spread: 0.5,
            speed: 3,
            life: 20
        });
    }

    emitDashParticles() {
        game.particles?.emit(this.x + this.width/2, this.y + this.height/2, 20, {
            colors: ['#00ffff', '#0088ff', '#ffffff'],
            angle: this.facingRight ? Math.PI : 0,
            spread: 0.3,
            speed: 8,
            type: 'spark',
            life: 15
        });
    }

    emitAttackParticles() {
        const offsetX = this.facingRight ? this.width + 20 : -20;
        const furyColors = this.powerups.fury > 0 ? ['#ff0000', '#ff4400', '#ffff00'] : ['#ffffff', '#ffff88', '#ffaa00'];
        game.particles?.emit(this.x + offsetX, this.y + this.height/2 - 10, 8, {
            colors: furyColors,
            angle: this.facingRight ? 0 : Math.PI,
            spread: 0.5,
            speed: 6,
            type: 'spark',
            life: 10
        });
    }

    getAttackBox() {
        if (this.attackDuration > 0) {
            const baseRange = 50;
            const rangeMultiplier = this.character.stats.attackRange || 1;
            const range = baseRange * rangeMultiplier;
            return {
                x: this.facingRight ? this.x + this.width : this.x - range,
                y: this.y,
                w: range,
                h: this.height
            };
        }
        return null;
    }

    getAttackDamage() {
        const baseDamage = this.character.stats.damage;
        const furyMultiplier = this.powerups.fury > 0 ? 2 : 1;
        return baseDamage * furyMultiplier;
    }

    draw(ctx, cameraX) {
        if (this.invincible > 0 && Math.floor(this.invincible / 4) % 2 === 0) return;

        const screenX = this.x - cameraX + this.width/2;
        const screenY = this.y + this.height - 30;
        const isMoving = Math.abs(this.vx) > 0.3 || !this.grounded || this.dashing;

        // Power-up visual effects
        ctx.save();

        // Shield bubble
        if (this.powerups.shield > 0) {
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.3 + Math.sin(game.frame * 0.1) * 0.2;
            ctx.beginPath();
            ctx.ellipse(screenX, screenY - 10, 35, 45, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        // Fury aura
        if (this.powerups.fury > 0) {
            ctx.shadowColor = '#ff4400';
            ctx.shadowBlur = 20 + Math.sin(game.frame * 0.2) * 10;
        }

        // Speed boost trail
        if (this.powerups.speedBoost > 0) {
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 15;
        }

        // Dash trail
        if (this.dashing) {
            ctx.globalAlpha = 0.3;
            for (let i = 1; i <= 3; i++) {
                const trailX = screenX - (this.facingRight ? i * 15 : -i * 15);
                Sprites.drawPixelCharacter(ctx, trailX, screenY, this.animFrame - i * 2, this.facingRight, this.state, true, this.colors);
            }
            ctx.globalAlpha = 1;
        }

        Sprites.drawPixelCharacter(ctx, screenX, screenY, this.animFrame, this.facingRight, this.state, isMoving, this.colors);

        ctx.restore();
    }
}

// Enemy Class
class Enemy {
    constructor(data) {
        this.x = data.x;
        this.y = data.y;
        this.type = data.type;
        this.patrolStart = data.patrolStart;
        this.patrolEnd = data.patrolEnd;
        this.direction = 1;
        this.width = 40;
        this.height = 60;
        this.health = data.type === 'ghost' ? 1 : 2;
        this.animFrame = Math.random() * 100;
        this.dead = false;
        this.deathTimer = 0;
    }

    update() {
        if (this.dead) {
            this.deathTimer++;
            return this.deathTimer < 30;
        }

        this.animFrame++;

        // Patrol movement
        const speed = this.type === 'ghost' ? 0.5 : 0.4;
        this.x += this.direction * speed;

        if (this.x <= this.patrolStart) {
            this.direction = 1;
        } else if (this.x >= this.patrolEnd) {
            this.direction = -1;
        }

        // Ghost floats
        if (this.type === 'ghost') {
            this.y = this.y + Math.sin(this.animFrame * 0.05) * 0.5;
        }

        return true;
    }

    takeDamage() {
        this.health--;
        game.audio?.enemyHit();

        // Hit particles
        game.particles?.emit(this.x + this.width/2, this.y + this.height/2, 10, {
            colors: this.type === 'ghost' ? ['#aaccff', '#88aaff', '#ffffff'] : ['#e8e8d8', '#888', '#666'],
            speed: 4,
            spread: Math.PI * 2,
            life: 25
        });

        if (this.health <= 0) {
            this.dead = true;
            game.score += this.type === 'ghost' ? 200 : 100;
            SaveManager.data.stats.enemiesDefeated++;
            document.getElementById('score').textContent = game.score;

            // Death burst
            game.particles?.emit(this.x + this.width/2, this.y + this.height/2, 25, {
                colors: this.type === 'ghost' ? ['#aaccff', '#88aaff', '#ffffff'] : ['#e8e8d8', '#aa0000', '#666'],
                speed: 6,
                spread: Math.PI * 2,
                life: 40,
                type: 'star'
            });
        }
    }

    draw(ctx, cameraX) {
        if (this.dead) {
            ctx.globalAlpha = 1 - this.deathTimer / 30;
        }

        const screenX = this.x - cameraX + this.width/2;
        const screenY = this.y + this.height - 30;

        Sprites.drawEnemy(ctx, screenX, screenY, this.animFrame, this.type, this.direction > 0);

        ctx.globalAlpha = 1;
    }

    collidesWith(player) {
        if (this.dead) return false;
        return player.x < this.x + this.width &&
               player.x + player.width > this.x &&
               player.y < this.y + this.height &&
               player.y + player.height > this.y;
    }

    collidesWithAttack(box) {
        if (this.dead || !box) return false;
        return box.x < this.x + this.width &&
               box.x + box.w > this.x &&
               box.y < this.y + this.height &&
               box.y + box.h > this.y;
    }
}

// Treasure Class
class Treasure {
    constructor(data) {
        this.x = data.x;
        this.y = data.y;
        this.type = data.type;
        this.collected = false;
        this.animFrame = Math.random() * 100;
    }

    update() {
        this.animFrame++;
        return !this.collected;
    }

    collect() {
        if (this.collected) return;
        this.collected = true;

        if (this.type === 'coin') {
            game.score += 50;
            game.audio?.coin();
            game.particles?.emit(this.x, this.y, 10, {
                colors: ['#ffd700', '#ffaa00', '#ffffff'],
                speed: 3,
                spread: Math.PI * 2,
                life: 30,
                type: 'star'
            });
            AchievementSystem.check('treasure_hunter');
        } else if (this.type === 'gem') {
            game.gems++;
            game.score += 200;
            SaveManager.addGems(1);
            game.audio?.gem();
            game.particles?.emit(this.x, this.y, 20, {
                colors: ['#ff00ff', '#ff88ff', '#ffffff'],
                speed: 4,
                spread: Math.PI * 2,
                life: 40,
                type: 'star'
            });
            AchievementSystem.check('treasure_hunter');
            AchievementSystem.check('wealthy');
        } else if (this.type === 'chest') {
            game.score += 1000;
            game.gems += 5;
            SaveManager.addGems(5);
            game.audio?.gem();
            if (SaveManager.data.settings.screenShake) game.screenShake = 15;
            game.particles?.emit(this.x, this.y, 50, {
                colors: ['#ffd700', '#ff8800', '#ffffff', '#ff00ff'],
                speed: 6,
                spread: Math.PI * 2,
                life: 60,
                type: 'star'
            });
            AchievementSystem.check('treasure_hunter', 5);
            AchievementSystem.check('wealthy', 5);
        } else if (this.type === 'health') {
            game.health = Math.min(Characters.getCurrent().stats.health, game.health + 25);
            game.particles?.emit(this.x, this.y, 15, {
                colors: ['#ff3333', '#ff8888', '#ffffff'],
                speed: 3,
                spread: Math.PI * 2,
                life: 30
            });
        }

        document.getElementById('gems').textContent = game.gems;
        document.getElementById('score').textContent = game.score;
        document.getElementById('health').textContent = game.health;
    }

    draw(ctx, cameraX) {
        const screenX = this.x - cameraX;
        if (screenX < -50 || screenX > CONFIG.WIDTH + 50) return;

        if (this.type === 'health') {
            Sprites.drawHealthPickup(ctx, screenX, this.y, this.animFrame);
        } else {
            Sprites.drawTreasure(ctx, screenX, this.y, this.animFrame, this.type);
        }
    }

    collidesWith(player) {
        if (this.collected) return false;
        const size = this.type === 'chest' ? 30 : 15;
        return player.x < this.x + size &&
               player.x + player.width > this.x - size &&
               player.y < this.y + size &&
               player.y + player.height > this.y - size;
    }
}

// Input handling
const keys = {
    left: false, right: false, jump: false, attack: false, dash: false
};

document.addEventListener('keydown', e => {
    // ESC to pause/unpause
    if (e.code === 'Escape') {
        if (GameState.current === 'playing') {
            GameState.pause();
        } else if (GameState.current === 'paused') {
            GameState.resume();
        }
        return;
    }

    // Only process game controls when playing
    if (GameState.current !== 'playing') return;

    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.jump = true;
    if (e.code === 'KeyX') keys.attack = true;
    if (e.code === 'KeyC') keys.dash = true;
});

document.addEventListener('keyup', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.jump = false;
    if (e.code === 'KeyX') keys.attack = false;
    if (e.code === 'KeyC') keys.dash = false;
});

canvas.addEventListener('click', () => {
    if (GameState.current === 'playing') {
        keys.attack = true;
        setTimeout(() => keys.attack = false, 100);
    }
});

// Handle name entry
document.getElementById('player-name-input')?.addEventListener('keydown', e => {
    if (e.code === 'Enter') {
        MenuSystem.startNewGame();
    }
});

// ============================================
// HAZARD RENDERING
// ============================================
function drawHazard(ctx, hazard, cameraX, frame) {
    const x = hazard.x - cameraX;
    if (x + hazard.w < -50 || x > CONFIG.WIDTH + 50) return;

    ctx.save();

    switch(hazard.type) {
        case 'spikes':
            ctx.fillStyle = '#444';
            for (let i = 0; i < hazard.w; i += 15) {
                ctx.beginPath();
                ctx.moveTo(x + i, hazard.y + hazard.h);
                ctx.lineTo(x + i + 7, hazard.y);
                ctx.lineTo(x + i + 14, hazard.y + hazard.h);
                ctx.closePath();
                ctx.fill();
            }
            // Shine on tips
            ctx.fillStyle = '#666';
            for (let i = 0; i < hazard.w; i += 15) {
                ctx.beginPath();
                ctx.arc(x + i + 7, hazard.y + 3, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            break;

        case 'lava':
            // Lava pool
            const lavaY = hazard.rising ? hazard.y - Math.sin(frame * 0.05) * 20 : hazard.y;
            ctx.fillStyle = '#ff4400';
            ctx.fillRect(x, lavaY, hazard.w, CONFIG.HEIGHT - lavaY);

            // Surface glow
            ctx.fillStyle = '#ff8800';
            ctx.fillRect(x, lavaY, hazard.w, 10);

            // Bubbles
            ctx.fillStyle = '#ffaa00';
            for (let i = 0; i < 3; i++) {
                const bubbleX = x + (i * 30 + frame) % hazard.w;
                const bubbleY = lavaY + 5 + Math.sin(frame * 0.1 + i) * 3;
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, 4 + Math.sin(frame * 0.2 + i) * 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Glow effect
            ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
            ctx.fillRect(x - 10, lavaY - 30, hazard.w + 20, 30);
            break;

        case 'water':
            // Water surface
            ctx.fillStyle = 'rgba(0, 100, 200, 0.6)';
            ctx.fillRect(x, hazard.y, hazard.w, hazard.h);

            // Waves
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < hazard.w; i += 5) {
                const waveY = hazard.y + Math.sin(frame * 0.1 + i * 0.1) * 3;
                if (i === 0) ctx.moveTo(x + i, waveY);
                else ctx.lineTo(x + i, waveY);
            }
            ctx.stroke();

            // Bubbles underwater
            ctx.fillStyle = 'rgba(200, 230, 255, 0.4)';
            for (let i = 0; i < 5; i++) {
                const bx = x + (i * 20 + Math.sin(frame * 0.02 + i) * 10) % hazard.w;
                const by = hazard.y + hazard.h - ((frame + i * 20) % hazard.h);
                ctx.beginPath();
                ctx.arc(bx, by, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            break;

        case 'wind':
            // Wind streaks
            ctx.strokeStyle = `rgba(200, 220, 255, ${0.3 + Math.sin(frame * 0.1) * 0.2})`;
            ctx.lineWidth = 2;
            for (let i = 0; i < 10; i++) {
                const startX = x + (i * 15 + frame * hazard.direction * 3) % hazard.w;
                const startY = hazard.y + (i * 7) % hazard.h;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(startX + hazard.direction * 20, startY);
                ctx.stroke();
            }
            break;

        case 'pit':
            // Bottomless pit - just darkness
            ctx.fillStyle = '#000';
            ctx.fillRect(x, hazard.y, hazard.w, hazard.h);
            // Fog at edges
            const gradient = ctx.createLinearGradient(x, hazard.y, x, hazard.y + 30);
            gradient.addColorStop(0, 'rgba(50, 50, 80, 0.5)');
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fillRect(x, hazard.y, hazard.w, 30);
            break;
    }

    ctx.restore();
}

function checkHazardCollision(player, hazards) {
    if (!hazards) return;

    hazards.forEach(h => {
        if (player.x + player.width > h.x &&
            player.x < h.x + h.w &&
            player.y + player.height > h.y &&
            player.y < h.y + h.h) {

            switch(h.type) {
                case 'spikes':
                    player.takeDamage(25);
                    player.vy = -5; // Bounce off
                    break;
                case 'lava':
                    player.takeDamage(10);
                    player.vy = -8; // Strong bounce
                    break;
                case 'water':
                    // Slow movement in water
                    player.vx *= 0.7;
                    player.vy *= 0.8;
                    // Slight damage over time
                    if (game.frame % 60 === 0) player.takeDamage(5);
                    break;
                case 'wind':
                    // Push player
                    player.vx += h.direction * 0.5;
                    break;
                case 'pit':
                    // Instant respawn
                    player.respawnAtCheckpoint();
                    break;
            }
        }
    });
}

// ============================================
// MAIN GAME LOOP
// ============================================
function gameLoop() {
    game.frame++;

    // Only update game logic when playing
    if (GameState.current === 'playing' && !GameState.isPaused) {
        // Update timer
        const elapsed = Math.floor((Date.now() - GameState.levelStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

        // Update player
        game.player.update(keys, game.platforms);

        // Camera follow with smoothing
        const targetCameraX = game.player.x - CONFIG.WIDTH / 3;
        game.cameraX += (targetCameraX - game.cameraX) * 0.08;
        game.cameraX = Math.max(0, Math.min(game.levelWidth - CONFIG.WIDTH, game.cameraX));

        // Screen shake
        if (game.screenShake > 0 && SaveManager.data.settings.screenShake) {
            game.screenShake--;
        }

        // Update entities
        game.enemies = game.enemies.filter(e => e.update());
        game.treasures = game.treasures.filter(t => t.update());
        game.checkpoints?.forEach(c => c.update());
        game.powerups = game.powerups?.filter(p => p.update()) || [];
        game.particles?.update();

        // Collision: Player attack vs Enemies
        const attackBox = game.player.getAttackBox();
        const attackDamage = game.player.getAttackDamage();
        game.enemies.forEach(e => {
            if (e.collidesWithAttack && e.collidesWithAttack(attackBox)) {
                if (e instanceof Boss) {
                    e.takeDamage(attackDamage);
                } else {
                    e.takeDamage();
                    AchievementSystem.checkEnemyKill(e.type);
                }
            }
        });

        // Collision: Enemies vs Player
        game.enemies.forEach(e => {
            if (e.collidesWith && e.collidesWith(game.player)) {
                game.player.takeDamage(e instanceof Boss ? 25 : 15);
            }
        });

        // Collision: Treasures vs Player
        game.treasures.forEach(t => {
            if (t.collidesWith(game.player)) {
                t.collect();
                GameState.levelGemsCollected++;
            }
        });

        // Collision: Checkpoints vs Player
        game.checkpoints?.forEach(c => {
            if (c.collidesWith(game.player)) {
                c.activate();
            }
        });

        // Collision: Powerups vs Player
        game.powerups?.forEach(p => {
            if (p.collidesWith(game.player)) {
                p.collect(game.player);
            }
        });

        // Check hazard collisions
        checkHazardCollision(game.player, game.hazards);

        // Check level completion (reached end and no boss or boss defeated)
        const levelData = LevelManager.currentLevelData;
        const hasBoss = game.enemies.some(e => e instanceof Boss && !e.dead);
        const atEnd = game.player.x > game.levelWidth - 200;

        if (atEnd && !hasBoss && levelData) {
            // For level 1 (no boss), complete when reaching end
            if (LevelManager.currentLevel === 1 && game.treasures.every(t => t.type !== 'chest' || t.collected)) {
                GameState.levelComplete();
            }
        }
    }

    // Always draw
    let shakeX = 0, shakeY = 0;
    if (game.screenShake > 0 && SaveManager.data.settings.screenShake) {
        shakeX = (Math.random() - 0.5) * game.screenShake;
        shakeY = (Math.random() - 0.5) * game.screenShake;
    }

    ctx.save();
    ctx.translate(shakeX, shakeY);

    // Draw background
    if (game.background) {
        game.background.draw(ctx, game.cameraX, game.frame);
    } else {
        ctx.fillStyle = '#0a0a12';
        ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
    }

    // Only draw game elements when in game states
    if (['playing', 'paused', 'gameOver', 'levelComplete'].includes(GameState.current) && game.player) {
        // Decorations behind
        game.decorations?.forEach(d => drawDecoration(ctx, d, game.cameraX, game.frame));

        // Hazards (behind platforms)
        game.hazards?.forEach(h => drawHazard(ctx, h, game.cameraX, game.frame));

        // Platforms
        game.platforms?.forEach(p => drawPlatform(ctx, p, game.cameraX));

        // Checkpoints
        game.checkpoints?.forEach(c => c.draw(ctx, game.cameraX));

        // Powerups
        game.powerups?.forEach(p => p.draw(ctx, game.cameraX));

        // Treasures
        game.treasures?.forEach(t => t.draw(ctx, game.cameraX));

        // Enemies
        game.enemies?.forEach(e => e.draw(ctx, game.cameraX));

        // Player
        game.player.draw(ctx, game.cameraX);

        // Particles (on top)
        ctx.save();
        ctx.translate(-game.cameraX, 0);
        game.particles?.draw(ctx);
        ctx.restore();
    }

    // Vignette effect
    const vignette = ctx.createRadialGradient(
        CONFIG.WIDTH/2, CONFIG.HEIGHT/2, CONFIG.HEIGHT * 0.4,
        CONFIG.WIDTH/2, CONFIG.HEIGHT/2, CONFIG.HEIGHT
    );
    vignette.addColorStop(0, 'transparent');
    vignette.addColorStop(1, 'rgba(0, 0, 0, 0.6)');
    ctx.fillStyle = vignette;
    ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

    ctx.restore();

    requestAnimationFrame(gameLoop);
}

// ============================================
// INITIALIZATION
// ============================================
function init() {
    // Initialize save system
    SaveManager.init();

    // Initialize particles
    game.particles = new ParticleSystem();

    // Set initial state
    GameState.setState('mainMenu');

    // Start game loop
    gameLoop();
}

// Start the game when page loads
init();
</script>
</body>
</html>
